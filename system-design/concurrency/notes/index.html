<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://ruihan.org/system-design/concurrency/notes/ rel=canonical><link rel="shortcut icon" href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.0.2"><title>Concurrency and Synchronization - RUIHAN.ORG</title><link rel=stylesheet href=../../../assets/stylesheets/main.38780c08.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f72e892.min.css><meta name=theme-color content=#000000><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=black data-md-color-accent=black> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#concurrency-and-synchronization class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=https://ruihan.org title=RUIHAN.ORG class="md-header-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> RUIHAN.ORG </span> <span class="md-header-nav__topic md-ellipsis"> Concurrency and Synchronization </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class="md-tabs md-tabs--active" aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../books/ class=md-tabs__link> Books </a> </li> <li class=md-tabs__item> <a href=../../../courses/ class=md-tabs__link> Courses </a> </li> <li class=md-tabs__item> <a href=../../../leetcode/ class=md-tabs__link> Leetcode </a> </li> <li class=md-tabs__item> <a href=../../../research/ class=md-tabs__link> Research </a> </li> <li class=md-tabs__item> <a href=../../../seedlabs/ class=md-tabs__link> SEED Labs </a> </li> <li class=md-tabs__item> <a href=../../ class="md-tabs__link md-tabs__link--active"> System Design </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=https://ruihan.org title=RUIHAN.ORG class="md-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> RUIHAN.ORG </label> <div class=md-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1> <label class=md-nav__link for=nav-1> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../books/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../books/accelerated-cpp/notes/ class=md-nav__link> Accelerated C++ </a> </li> <li class=md-nav__item> <a href=../../../books/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Datasets </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Courses <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Courses data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Courses </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../courses/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../courses/machine-learning-coursera/notes/ class=md-nav__link> Machine Learning (Coursera) </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/lec-notes/ class=md-nav__link> CS224N Lecture Notes </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/write-up/ class=md-nav__link> CS224N Write-up </a> </li> <li class=md-nav__item> <a href=../../../courses/coursera-dl4-cnn/notes/ class=md-nav__link> Convolutional Neural Networks </a> </li> <li class=md-nav__item> <a href=../../../courses/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Data Sets </a> </li> <li class=md-nav__item> <a href=../../../courses/6.431-probability/notes/ class=md-nav__link> 6.431 Probability </a> </li> <li class=md-nav__item> <a href=../../../courses/learning-from-data/notes.md class=md-nav__link> Learning From Data </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-system-design/notes/ class=md-nav__link> Nine Chapter System Design </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-dynamic-prog/notes/ class=md-nav__link> Nine Chapter Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../courses/func-prog-in-scala/notes/ class=md-nav__link> Functional Programming Principles in Scala </a> </li> <li class=md-nav__item> <a href=../../../courses/applied-scrum-for-agile/notes/ class=md-nav__link> Applied Scrum for Agile Project Management </a> </li> <li class=md-nav__item> <a href=../../../courses/concurrent-prog-java/notes/ class=md-nav__link> Concurrent Programming in Java </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3> <label class=md-nav__link for=nav-3> Leetcode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Leetcode data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> Leetcode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../leetcode/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../leetcode/array/notes/ class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../../leetcode/backtracking/notes/ class=md-nav__link> Backtracking </a> </li> <li class=md-nav__item> <a href=../../../leetcode/binary-search/notes/ class=md-nav__link> Binary Search </a> </li> <li class=md-nav__item> <a href=../../../leetcode/breadth-first-search/notes/ class=md-nav__link> Breadth-First Search (BFS) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/depth-first-search/notes/ class=md-nav__link> Depth-First Search (DFS) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/dynamic-programming/notes/ class=md-nav__link> Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../leetcode/graph/notes/ class=md-nav__link> Graph </a> </li> <li class=md-nav__item> <a href=../../../leetcode/heap/notes/ class=md-nav__link> Heap </a> </li> <li class=md-nav__item> <a href=../../../leetcode/interval/notes/ class=md-nav__link> Interval </a> </li> <li class=md-nav__item> <a href=../../../leetcode/linked-list/notes/ class=md-nav__link> Linked List </a> </li> <li class=md-nav__item> <a href=../../../leetcode/math/notes/ class=md-nav__link> Math </a> </li> <li class=md-nav__item> <a href=../../../leetcode/stack/notes/ class=md-nav__link> Stack </a> </li> <li class=md-nav__item> <a href=../../../leetcode/string/notes/ class=md-nav__link> String </a> </li> <li class=md-nav__item> <a href=../../../leetcode/tree/notes/ class=md-nav__link> Tree </a> </li> <li class=md-nav__item> <a href=../../../leetcode/trie/notes/ class=md-nav__link> Trie </a> </li> <li class=md-nav__item> <a href=../../../leetcode/union-find/notes/ class=md-nav__link> Union Find </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Research <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Research data-md-level=1> <label class=md-nav__title for=nav-4> <span class="md-nav__icon md-icon"></span> Research </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../research/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../research/paper-reading/notes/ class=md-nav__link> Paper Reading </a> </li> <li class=md-nav__item> <a href=../../../research/coalition-game/notes/ class=md-nav__link> Coalition Game </a> </li> <li class=md-nav__item> <a href=../../../research/contextual-bandit/notes/ class=md-nav__link> Contextual Multi-Armed Bandit </a> </li> <li class=md-nav__item> <a href=../../../research/tfidf-score/notes/ class=md-nav__link> TF-IDF for Information Retrieval </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> SEED Labs <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SEED Labs" data-md-level=1> <label class=md-nav__title for=nav-5> <span class="md-nav__icon md-icon"></span> SEED Labs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../seedlabs/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/applied-crypto/notes/ class=md-nav__link> Applied Cryptograph Notes </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ class=md-nav__link> Public Key Cryptography and PKI </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-6 type=checkbox id=nav-6 checked> <label class=md-nav__link for=nav-6> System Design <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="System Design" data-md-level=1> <label class=md-nav__title for=nav-6> <span class="md-nav__icon md-icon"></span> System Design </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../browser/notes.md class=md-nav__link> How Browser Works </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Concurrency and Synchronization <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Concurrency and Synchronization </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#thread-and-concurrency class=md-nav__link> Thread and concurrency </a> <nav class=md-nav aria-label="Thread and concurrency"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#thread-memory-model class=md-nav__link> Thread memory model </a> </li> <li class=md-nav__item> <a href=#variable-mapping-in-memory class=md-nav__link> Variable mapping in memory </a> <nav class=md-nav aria-label="Variable mapping in memory"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#global-variables class=md-nav__link> Global variables </a> </li> <li class=md-nav__item> <a href=#local-variables class=md-nav__link> Local variables </a> </li> <li class=md-nav__item> <a href=#local-static-variables class=md-nav__link> Local static variables </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#synchronization-basic-concepts class=md-nav__link> Synchronization basic concepts </a> </li> <li class=md-nav__item> <a href=#lock class=md-nav__link> Lock </a> <nav class=md-nav aria-label=Lock> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pthread-example class=md-nav__link> pthread example </a> </li> <li class=md-nav__item> <a href=#implement-a-lock class=md-nav__link> Implement a lock </a> <nav class=md-nav aria-label="Implement a lock"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#controlling-interrupts class=md-nav__link> Controlling Interrupts </a> </li> <li class=md-nav__item> <a href=#test-and-set-automic-exchange class=md-nav__link> Test-and-set (automic exchange) </a> </li> <li class=md-nav__item> <a href=#compare-and-swap class=md-nav__link> Compare-and-swap </a> </li> <li class=md-nav__item> <a href=#load-linked-and-store-conditional class=md-nav__link> Load-linked and store-conditional </a> </li> <li class=md-nav__item> <a href=#fetch-and-add class=md-nav__link> Fetch-and-add </a> </li> <li class=md-nav__item> <a href=#how-to-avoid-spinning class=md-nav__link> How to avoid spinning </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#conditional-variables class=md-nav__link> Conditional variables </a> <nav class=md-nav aria-label="Conditional variables"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#backgroud class=md-nav__link> Backgroud </a> </li> <li class=md-nav__item> <a href=#definition class=md-nav__link> Definition </a> </li> <li class=md-nav__item> <a href=#c-pthread-routine class=md-nav__link> C++ pthread routine </a> </li> <li class=md-nav__item> <a href=#basic-ideas class=md-nav__link> basic ideas </a> </li> <li class=md-nav__item> <a href=#example-of-using-a-conditional-variable class=md-nav__link> Example of using a conditional variable </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#producers-consumers-problem class=md-nav__link> Producers-consumers problem </a> <nav class=md-nav aria-label="Producers-consumers problem"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#our-first-solution class=md-nav__link> Our first solution </a> </li> <li class=md-nav__item> <a href=#mesa-semantics-and-hoare-semantics class=md-nav__link> Mesa semantics and Hoare semantics </a> </li> <li class=md-nav__item> <a href=#single-buffer-producerconsumer-solution class=md-nav__link> Single buffer producer/consumer solution </a> </li> <li class=md-nav__item> <a href=#producer-consumer-solution class=md-nav__link> Producer consumer solution </a> </li> <li class=md-nav__item> <a href=#covering-conditions class=md-nav__link> Covering Conditions </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#semaphore class=md-nav__link> Semaphore </a> <nav class=md-nav aria-label=Semaphore> <ul class=md-nav__list> <li class=md-nav__item> <a href=#definition_1 class=md-nav__link> Definition </a> </li> <li class=md-nav__item> <a href=#semaphore-as-a-lock class=md-nav__link> Semaphore as a lock </a> </li> <li class=md-nav__item> <a href=#semaphores-as-conditional-variables class=md-nav__link> Semaphores as conditional variables </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#deadlock class=md-nav__link> Deadlock </a> </li> <li class=md-nav__item> <a href=#monitor class=md-nav__link> Monitor </a> </li> <li class=md-nav__item> <a href=#dining-philosophers-problem class=md-nav__link> Dining philosophers problem </a> </li> <li class=md-nav__item> <a href=#applications class=md-nav__link> Applications </a> </li> <li class=md-nav__item> <a href=#reference class=md-nav__link> Reference </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../concepts/notes/ class=md-nav__link> Distributed System Concepts </a> </li> <li class=md-nav__item> <a href=../../patterns/notes/ class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../problems/tinyurl/notes/ class=md-nav__link> How to Design TinyUrl </a> </li> <li class=md-nav__item> <a href=../../problems/twitter/notes/ class=md-nav__link> How to Design Twitter </a> </li> <li class=md-nav__item> <a href=../../problems/ticketmaster/notes/ class=md-nav__link> How to Design Ticketmaster </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#thread-and-concurrency class=md-nav__link> Thread and concurrency </a> <nav class=md-nav aria-label="Thread and concurrency"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#thread-memory-model class=md-nav__link> Thread memory model </a> </li> <li class=md-nav__item> <a href=#variable-mapping-in-memory class=md-nav__link> Variable mapping in memory </a> <nav class=md-nav aria-label="Variable mapping in memory"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#global-variables class=md-nav__link> Global variables </a> </li> <li class=md-nav__item> <a href=#local-variables class=md-nav__link> Local variables </a> </li> <li class=md-nav__item> <a href=#local-static-variables class=md-nav__link> Local static variables </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#synchronization-basic-concepts class=md-nav__link> Synchronization basic concepts </a> </li> <li class=md-nav__item> <a href=#lock class=md-nav__link> Lock </a> <nav class=md-nav aria-label=Lock> <ul class=md-nav__list> <li class=md-nav__item> <a href=#pthread-example class=md-nav__link> pthread example </a> </li> <li class=md-nav__item> <a href=#implement-a-lock class=md-nav__link> Implement a lock </a> <nav class=md-nav aria-label="Implement a lock"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#controlling-interrupts class=md-nav__link> Controlling Interrupts </a> </li> <li class=md-nav__item> <a href=#test-and-set-automic-exchange class=md-nav__link> Test-and-set (automic exchange) </a> </li> <li class=md-nav__item> <a href=#compare-and-swap class=md-nav__link> Compare-and-swap </a> </li> <li class=md-nav__item> <a href=#load-linked-and-store-conditional class=md-nav__link> Load-linked and store-conditional </a> </li> <li class=md-nav__item> <a href=#fetch-and-add class=md-nav__link> Fetch-and-add </a> </li> <li class=md-nav__item> <a href=#how-to-avoid-spinning class=md-nav__link> How to avoid spinning </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#conditional-variables class=md-nav__link> Conditional variables </a> <nav class=md-nav aria-label="Conditional variables"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#backgroud class=md-nav__link> Backgroud </a> </li> <li class=md-nav__item> <a href=#definition class=md-nav__link> Definition </a> </li> <li class=md-nav__item> <a href=#c-pthread-routine class=md-nav__link> C++ pthread routine </a> </li> <li class=md-nav__item> <a href=#basic-ideas class=md-nav__link> basic ideas </a> </li> <li class=md-nav__item> <a href=#example-of-using-a-conditional-variable class=md-nav__link> Example of using a conditional variable </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#producers-consumers-problem class=md-nav__link> Producers-consumers problem </a> <nav class=md-nav aria-label="Producers-consumers problem"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#our-first-solution class=md-nav__link> Our first solution </a> </li> <li class=md-nav__item> <a href=#mesa-semantics-and-hoare-semantics class=md-nav__link> Mesa semantics and Hoare semantics </a> </li> <li class=md-nav__item> <a href=#single-buffer-producerconsumer-solution class=md-nav__link> Single buffer producer/consumer solution </a> </li> <li class=md-nav__item> <a href=#producer-consumer-solution class=md-nav__link> Producer consumer solution </a> </li> <li class=md-nav__item> <a href=#covering-conditions class=md-nav__link> Covering Conditions </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#semaphore class=md-nav__link> Semaphore </a> <nav class=md-nav aria-label=Semaphore> <ul class=md-nav__list> <li class=md-nav__item> <a href=#definition_1 class=md-nav__link> Definition </a> </li> <li class=md-nav__item> <a href=#semaphore-as-a-lock class=md-nav__link> Semaphore as a lock </a> </li> <li class=md-nav__item> <a href=#semaphores-as-conditional-variables class=md-nav__link> Semaphores as conditional variables </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#deadlock class=md-nav__link> Deadlock </a> </li> <li class=md-nav__item> <a href=#monitor class=md-nav__link> Monitor </a> </li> <li class=md-nav__item> <a href=#dining-philosophers-problem class=md-nav__link> Dining philosophers problem </a> </li> <li class=md-nav__item> <a href=#applications class=md-nav__link> Applications </a> </li> <li class=md-nav__item> <a href=#reference class=md-nav__link> Reference </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=concurrency-and-synchronization>Concurrency and Synchronization<a class=headerlink href=#concurrency-and-synchronization title="Permanent link">&para;</a></h1> <h2 id=thread-and-concurrency>Thread and concurrency<a class=headerlink href=#thread-and-concurrency title="Permanent link">&para;</a></h2> <h3 id=thread-memory-model>Thread memory model<a class=headerlink href=#thread-memory-model title="Permanent link">&para;</a></h3> <ol> <li>Multiple threads run within the context of a process.</li> <li>Each thread has its own separate thread context<ul> <li>Thread ID, stack, stack pointer, PC, condition codes, and GP registers</li> </ul> </li> <li>All threads share the remaining process context<ul> <li>Code, data, heap, and shared library segments in the process virtual address space</li> <li>File descriptors and opened handles</li> </ul> </li> </ol> <p>However, the above conceptual model is not strictly enforced in practice. Operationally, the registers are truly separated and protected, but any thread can read and write the stack of any other thread!</p> <h3 id=variable-mapping-in-memory>Variable mapping in memory<a class=headerlink href=#variable-mapping-in-memory title="Permanent link">&para;</a></h3> <h4 id=global-variables>Global variables<a class=headerlink href=#global-variables title="Permanent link">&para;</a></h4> <ul> <li>Definition: Variable declared outside of a function</li> <li>Virtual memory contains exactly one instance of any global variable.</li> </ul> <h4 id=local-variables>Local variables<a class=headerlink href=#local-variables title="Permanent link">&para;</a></h4> <ul> <li>Definition: Variable declared inside a function without <strong>static</strong> keyword.</li> <li>Each thread stack contains one instant of each local variable.</li> </ul> <h4 id=local-static-variables>Local static variables<a class=headerlink href=#local-static-variables title="Permanent link">&para;</a></h4> <ul> <li>Definition: Variable declared inside a function with <strong>static</strong> keyword.</li> <li>Virtual memory contains exactly one instance of any local static variable.</li> </ul> <p>While different threads try to access the same shared variable (data structure) at the same time, they face a synchronous problem. The operations involved have to pertain a certain order so as the variable value will be correct. We need to design a mechanism to prevent this type of synchronous problem from happening. We do so by ensuring <strong>mutual exclusive</strong> of the two events, namely, event A and event B must not happen at the same time.</p> <h2 id=synchronization-basic-concepts>Synchronization basic concepts<a class=headerlink href=#synchronization-basic-concepts title="Permanent link">&para;</a></h2> <ul> <li>A <strong>critical section</strong> is a piece of code that accesses a shared resource, usually a variable or data structure.</li> <li>A <strong>race condition</strong> arises if multiple threads of execution enter the critical section at roughly the same time; both attempt to update the shared data structure, leading to a surprising (and perhaps undesirable) outcome.</li> <li><strong>Mutual exclusive</strong> is the requirement one want to fulfill if multiple threads want to access/update/modify the same variable. This property guarantees that if one thread is executing within the critical section, the others will be prevented from doing so.</li> </ul> <h2 id=lock>Lock<a class=headerlink href=#lock title="Permanent link">&para;</a></h2> <h3 id=pthread-example>pthread example<a class=headerlink href=#pthread-example title="Permanent link">&para;</a></h3> <p>A lock is just like a variable, To use a lock, you first declare a lock variable, the variable hold the state of the lock across all instance of time. Its state is either in available (unlocked or free) or in acquired (locked or held). To use a lock, we add some code around the critical section like the following code.</p> <div class=highlight><pre><span></span><code><span class=n>pthread_mutex_t</span> <span class=n>lock</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
<span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
<span class=n>balance</span> <span class=o>=</span> <span class=n>balance</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// critical section</span>
<span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=p>);</span>
</code></pre></div> <h3 id=implement-a-lock>Implement a lock<a class=headerlink href=#implement-a-lock title="Permanent link">&para;</a></h3> <p>Many programming interfaces provide locking mechanisms through interfaces that are easy to use, but:</p> <ul> <li>How can we build an efficient lock?</li> <li>What hardware support is needs?</li> <li>What OS support is needed?</li> </ul> <p>Before building locks, let's summarize the properties a lock might have so that we can evaluate the lock we build.</p> <ol> <li><strong>mutual exclusive</strong>. Basic task, make sure event A and event B cannot happen at the same time.</li> <li><strong>fairness</strong>. Each thread competing for the lock should get a fair chance to acquire the lock once the lock has been released.</li> <li><strong>performance</strong>. How much overhead is added by using the lock? There are three cases we have to consider:<ul> <li>single thread using the lock.</li> <li>multiple threads contending for the lock and run on a single CPU.</li> <li>multiple threads contending for the lock and run on multiple CPUs.</li> </ul> </li> </ol> <h4 id=controlling-interrupts>Controlling Interrupts<a class=headerlink href=#controlling-interrupts title="Permanent link">&para;</a></h4> <ul> <li>pros<ol> <li>simplicity</li> </ol> </li> <li>cons<ol> <li>performing operations on interrupts are privileged. OS need to fully trust the applications. Otherwise, abuses of the system facility may happen, such as monopolize the CPU or faulty applications go into an endless loop.</li> <li>doesn't work on multiprocessors.</li> <li>Turning off interrupts for extended periods of time can lead to interrupts becoming lost. e.g. missing a disk I/O interrupt may cause a process waiting for the completion of the file write never wakeup.</li> <li>Inefficient due to slow execution of the code that interrupts have been masked and unmasked.</li> </ol> </li> </ul> <h4 id=test-and-set-automic-exchange>Test-and-set (automic exchange)<a class=headerlink href=#test-and-set-automic-exchange title="Permanent link">&para;</a></h4> <p>One idea that could be potentially useful in implementing a lock is using a flag as a lock. Thread who acquires the lock will set the flag to <code>1</code> while entering the critical section and reset to <code>0</code> when finished the critical section. This idea will <strong>NOT</strong> work since if two threads attempt to acquire the lock at the same time, the operations may interleave thus result in acquiring the lock at the same time.</p> <p>The problem with the above simple idea is that the operations to test the flag and set it to 1 aren't atomic. Nowadays, most hardware architecture has instructions that support lock. In x86 platform, the atomic exchange instruction <code>xchg</code> enables us to implement a "spin-lock" using the above "flag" idea. Such hardware support instructions are generally referred to as "Test-and-set" operation. Below includes the C snippet of a "Test-and-set" operation. It is an atomic operation. Imagine it as an equivalent to the single instruction <code>xchg</code>. What it does is return the old value and set the old value to the new value in one operation.</p> <div class=tabbed-set data-tabs=1:1><input checked=checked id=__tabbed_1_1 name=__tabbed_1 type=radio><label for=__tabbed_1_1>implement the spin lock using Test-and-set</label><div class=tabbed-content> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>TestAndSet</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>old_ptr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>new_val</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>old</span> <span class=o>=</span> <span class=o>*</span><span class=n>old_ptr</span><span class=p>;</span> <span class=c1>//fetch old value at old_ptr</span>
    <span class=o>*</span><span class=n>old_ptr</span> <span class=o>=</span> <span class=n>new_val</span><span class=p>;</span> <span class=c1>//store new_val into old_ptr</span>
    <span class=k>return</span> <span class=n>old</span><span class=p>;</span>         <span class=c1>//return the old value</span>
<span class=p>}</span>

<span class=k>typedef</span> <span class=k>struct</span> <span class=nc>__lock_t</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>flag</span><span class=p>;</span>
<span class=p>}</span> <span class=n>lock_t</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>init</span><span class=p>(</span><span class=n>lock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 0 indicate free, 1 indicate acquired</span>
    <span class=n>lock</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>lock</span><span class=p>(</span><span class=n>lock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>TestAndSet</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>flag</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
        <span class=p>;</span> <span class=c1>//spin wait</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>unlock</span><span class=p>(</span><span class=n>lock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>lock</span><span class=o>-&gt;</span><span class=n>flag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> </div> </div> <div class="admonition note"> <p class=admonition-title>Evaluation of the spin lock using Test-and-set</p> <ol> <li>Correctness: provide mutual exclusive</li> <li>Fairness: not fair.</li> <li>Performance: spinning waste CPU cycles.</li> </ol> </div> <h4 id=compare-and-swap>Compare-and-swap<a class=headerlink href=#compare-and-swap title="Permanent link">&para;</a></h4> <p>Compare-and-swap is another hardware primitive that some system provided. Compare-and-swap on SPARC systems and compare-and-exchange on x86. Here is the C snippet of the operations. It is atomically accomplished in machine level instruction.</p> <div class=tabbed-set data-tabs=2:1><input checked=checked id=__tabbed_2_1 name=__tabbed_2 type=radio><label for=__tabbed_2_1>Implement spin lock with Compare-and-swap</label><div class=tabbed-content> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>CompareAndSwap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>old_ptr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>expected</span><span class=p>,</span> <span class=kt>int</span> <span class=n>new_val</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>old</span> <span class=o>=</span> <span class=o>*</span><span class=n>old_ptr</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>old_ptr</span> <span class=o>==</span> <span class=n>expected</span><span class=p>)</span> <span class=p>{</span>
        <span class=o>*</span><span class=n>old_ptr</span> <span class=o>=</span> <span class=n>new_val</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>old</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>lock</span><span class=p>(</span><span class=n>lock_t</span> <span class=o>*</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>CompareAndSwap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lock</span><span class=o>-&gt;</span><span class=n>flag</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
        <span class=p>;</span> <span class=c1>//spin wait</span>
<span class=p>}</span>
</code></pre></div> </div> </div> <p>!Note "" Although we saw that Test-and-set and compare-and-swap atomic instructions are very similar in implementing spinlocks, the later is more powerful instruction. We will see some of the good properties of the compare-and-swap instruction in <a href>lock-free synchronization</a>.</p> <h4 id=load-linked-and-store-conditional>Load-linked and store-conditional<a class=headerlink href=#load-linked-and-store-conditional title="Permanent link">&para;</a></h4> <p>TBD</p> <h4 id=fetch-and-add>Fetch-and-add<a class=headerlink href=#fetch-and-add title="Permanent link">&para;</a></h4> <p>TBD</p> <h4 id=how-to-avoid-spinning>How to avoid spinning<a class=headerlink href=#how-to-avoid-spinning title="Permanent link">&para;</a></h4> <p>Hardware support gets enable us to implement locks with correctness, namely mutual exclusive. We could also rely on hardware support to provide fairness as we saw in the fetch-and-add primitives in implementing ticket lock. But hardware alone will not provide us an efficient lock implementation. We need OS support to make the lock we discussed have good performance.</p> <p>Our first try is to yield when a thread tries to acquire a lock that already held by others. Instead of spinning, it immediately yields the CPU to allow other threads to finish the critical section. If we have only two processes contending for the lock, this approach works pretty well. But if we have many threads lets say 100 contending for the lock, this approach will be problematic again. There might be 99 threads yielding and doing context switches, the work of which can be substantially wasteful.</p> <p>Another solution to reduce the spinning is using queues. Put the thread into sleeping in a queue instead of spinning. When the lock is about to be released, the thread wakes up one of the sleeping threads in the sleeping queue attempted to acquire the lock. What we do here is to exert some control over which thread next gets to acquire the lock after the current holder release it. This solved the problem in the previous approaches. Using a queue to track the thread who want to acquire the lock and the thread who finished the critical section will select from the queue the next thread to run. Previously we leave too much to opportunity. It is the scheduler who determines which thread to run next. No matter which thread to select, it leaves too much CPU time spinning or yielding.</p> <p>Solaris example, use <code>park()</code>, <code>unpark</code>, and <code>setpark()</code></p> <h2 id=conditional-variables>Conditional variables<a class=headerlink href=#conditional-variables title="Permanent link">&para;</a></h2> <h3 id=backgroud>Backgroud<a class=headerlink href=#backgroud title="Permanent link">&para;</a></h3> <p>In the case that a thread wants to check whether a condition is true before continuing its execution, such as a parent thread may check whether its child has completed before continue its own execution. (i.e. <code>join()</code>) But how to implement such a <code>wait()</code>? Generally, a <strong>shared variable</strong> will work but not efficient enough because the parent have to spin.</p> <p>A not efficient implementation of wait(). Parent wait for child, spin based approach.</p> <div class=highlight><pre><span></span><code><span class=k>volatile</span> <span class=kt>int</span> <span class=n>done</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>child</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;child</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=n>done</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;parent: begin</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=n>pthread_t</span> <span class=n>c</span><span class=p>;</span>
    <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>child</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>done</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=p>;</span> <span class=c1>//spin wait</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;parent: end</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <h3 id=definition>Definition<a class=headerlink href=#definition title="Permanent link">&para;</a></h3> <p>A <strong>conditional variable</strong> is an explicit queue that threads can put themselves in and sleep (wait for being notified to change to ready) when a condition has not been met; some other thread later changes the condition and then wake one of those sleeping threads from the queue to notify them to continue.</p> <h3 id=c-pthread-routine>C++ pthread routine<a class=headerlink href=#c-pthread-routine title="Permanent link">&para;</a></h3> <ol> <li><code>pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);</code><ul> <li>mutex m should be acquired before calling wait()</li> <li>nutex m should be released when enter the wait()</li> <li>nutex m should be re-acquired upon return to caller.</li> </ul> </li> <li><code>pthread_cond_signal(pthread_cond_t *c);</code></li> </ol> <h3 id=basic-ideas>basic ideas<a class=headerlink href=#basic-ideas title="Permanent link">&para;</a></h3> <ul> <li>The general idea is when a thread wants to access the critical section, it first checks a conditional variable (like a flag) to decide whether it should wait on the condition (using pthread_cond_wait();) or keep running (fall off toward the function end).</li> <li>Another thread will set the conditional variable and wake up (using pthread_cond_signal();) the sleeping thread from the queue.</li> </ul> <h3 id=example-of-using-a-conditional-variable>Example of using a conditional variable<a class=headerlink href=#example-of-using-a-conditional-variable title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=c1>// Parent waiting for child: using a conditional variable</span>
<span class=kt>int</span> <span class=n>done</span> <span class=o>=</span> <span class=mi>0</span>
<span class=n>pthread_mutex_t</span> <span class=n>m</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
<span class=n>pthread_cond_t</span> <span class=n>c</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>thr_exit</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
    <span class=n>done</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>);</span>
    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=nf>thr_join</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>done</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>    
    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>child</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;child</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=n>thr_exit</span><span class=p>();</span>
    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;parent: begin</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=n>pthread_t</span> <span class=n>p</span><span class=p>;</span>
    <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>child</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
    <span class=n>thr_join</span><span class=p>();</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&quot;parent: end</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Analysis of the code snippet</p> <ul> <li>We interested in three variables in this program:<ol> <li><code>int done</code></li> <li><code>pthread_mutex_t m</code></li> <li><code>pthread_cond_t c</code></li> </ol> </li> <li>One may wondering whether the done and <code>m</code> state variables are a must. Let's see what if we don't have the done state variable. In this case, if the child run before the parent, the child will signal and there is no thread in the queue, child returns and then the parent start running, parent will wait if at this time the child is finished, no one will signal it. The parent just stuck!</li> <li>Let's see if we remove the lock m. It will introduce a race condition. Considering if the child interrupts the parent at the time right before the parent call <code>pthread_cond_wait()</code>, the child set the conditional variable and signal, there is no thread in the waiting queue, so child return. Then the parent goes to sleep, and not be able to wait up.</li> </ul> </div> <h2 id=producers-consumers-problem>Producers-consumers problem<a class=headerlink href=#producers-consumers-problem title="Permanent link">&para;</a></h2> <p>In this problem, we have to carefully synchronize the two (or more) threads in order for them to work correctly. Here are the <code>put()</code> to populate the buffer, and <code>get()</code> to read the buffer.</p> <h3 id=our-first-solution>Our first solution<a class=headerlink href=#our-first-solution title="Permanent link">&para;</a></h3> <p>Producers and consumers synchronization example,</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=n>buffer</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>put</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>assert</span><span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
    <span class=n>count</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>buffer</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>get</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>assert</span><span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
    <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>buffer</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>pthread_cond_t</span> <span class=n>cond</span><span class=p>;</span>
<span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>            <span class=c1>// p1</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// or use while        // p2</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>  <span class=c1>// p3</span>
        <span class=n>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>                                <span class=c1>// p4</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>);</span>            <span class=c1>// p5</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>          <span class=c1>// p6</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>            <span class=c1>// c1</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>  <span class=c1>// or use while       // c2</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>  <span class=c1>// c3</span>
        <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>get</span><span class=p>();</span>                       <span class=c1>// c4</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>cond</span><span class=p>);</span>            <span class=c1>// c5</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>          <span class=c1>// c6</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <p>Problem with this solution,</p> <ol> <li>It works ok if we have only one consumer and one producer.</li> <li>Problems could arise when we have more than one consumer.</li> <li>If we have more than one consumer, one of them might sneak in to consume the buffer before the other consumer return from <code>pthread_cond_wait()</code>.</li> </ol> <p><img alt="Broken solution with if statement" src=./fig/broken-solution-with-if-statement.png> <img alt="Broken solution with while statement" src=./fig/broken-solution-with-while-statement.png></p> <h3 id=mesa-semantics-and-hoare-semantics>Mesa semantics and Hoare semantics<a class=headerlink href=#mesa-semantics-and-hoare-semantics title="Permanent link">&para;</a></h3> <p>The problem with the <code>if</code> statement is that signaling a thread only wakes them up; it is thus a hint that the state of the world has changed but there is no guarantee that when the woken thread runs. This interpretation of what a signal means is often referred to as <strong>Mesa semantics</strong>; in contrast, referred to as <strong>Hoare semantics</strong>, is harder to build but provides a stronger guarantee that the woken thread will run immediately upon being woken.</p> <h3 id=single-buffer-producerconsumer-solution>Single buffer producer/consumer solution<a class=headerlink href=#single-buffer-producerconsumer-solution title="Permanent link">&para;</a></h3> <p>We saw from the above discussion that even change the if statement to while, we are still facing some problem that all producer thread and consumer thread will sleep. This is because one consumer signaled another consumer and the producer never be able to run again. To solve this problem we'd better to add another conditional variable, one for the producer and another for the consumer so that the producer can only signal the consumer and the consumer can only signal the producer. This sounds most plausible and the problem will never occur.</p> <p>Finally here is our workable solution with two conditional variables.</p> <div class=highlight><pre><span></span><code><span class=n>pthread_cond_t</span> <span class=n>empty</span><span class=p>,</span> <span class=n>fill</span><span class=p>;</span>
<span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fill</span><span class=p>);</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fill</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>get</span><span class=p>();</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=producer-consumer-solution>Producer consumer solution<a class=headerlink href=#producer-consumer-solution title="Permanent link">&para;</a></h3> <p>Now let's change the one element buffer to a more general solution, which has more buffers slots to work on for the consumers and the producers. This solution even support concurrent producing and consuming for multiple threads.</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=n>buffer</span><span class=p>[</span><span class=n>MAX</span><span class=p>];</span>
<span class=kt>int</span> <span class=n>fill_ptr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>use_ptr</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

<span class=kt>void</span> <span class=nf>put</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>buffer</span><span class=p>[</span><span class=n>fill_ptr</span><span class=p>]</span> <span class=o>=</span> <span class=n>value</span><span class=p>;</span>
    <span class=n>fill_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=n>fill_ptr</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX</span><span class=p>;</span>
    <span class=n>count</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>get</span><span class=p>()</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>use_ptr</span><span class=p>];</span>
    <span class=n>use_ptr</span> <span class=o>=</span> <span class=p>(</span><span class=n>use_ptr</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>MAX</span><span class=p>;</span>
    <span class=n>count</span><span class=o>--</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>pthread_cond_t</span> <span class=n>empty</span><span class=p>,</span> <span class=n>fill</span><span class=p>;</span>
<span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>producer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=n>MAX</span><span class=p>)</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>put</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fill</span><span class=p>);</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span> <span class=o>*</span><span class=nf>consumer</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>loops</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loops</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>fill</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>get</span><span class=p>();</span>
        <span class=n>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>empty</span><span class=p>);</span>
        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%d</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>tmp</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> <h3 id=covering-conditions>Covering Conditions<a class=headerlink href=#covering-conditions title="Permanent link">&para;</a></h3> <p>TBD</p> <h2 id=semaphore>Semaphore<a class=headerlink href=#semaphore title="Permanent link">&para;</a></h2> <ol> <li>What is the definition of a semaphore?</li> <li>How can we use semaphores instead of locks and condition variables?</li> <li>What is a binary semaphore?</li> <li>Is it straightforward to build a semaphore out of locks and condition variables? to build locks and condition variables out of semaphores?</li> </ol> <h3 id=definition_1>Definition<a class=headerlink href=#definition_1 title="Permanent link">&para;</a></h3> <p>A semaphore is an object with an integer value that we can manipulate with two routines; in the POSIX standard, these routines are <code>sem_wait()</code> and <code>sem_post()</code>.</p> <div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>sem_wait</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>decrement</span> <span class=n>the</span> <span class=n>value</span> <span class=n>of</span> <span class=n>semaphore</span> <span class=n>s</span> <span class=n>by</span> <span class=n>one</span>
    <span class=n>wait</span> <span class=k>if</span> <span class=n>value</span> <span class=n>of</span> <span class=n>semaphore</span> <span class=n>s</span> <span class=n>is</span> <span class=n>negative</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>sem_post</span><span class=p>(</span><span class=n>sem_t</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>increment</span> <span class=n>the</span> <span class=n>value</span> <span class=n>of</span> <span class=n>semaphore</span> <span class=n>s</span> <span class=n>by</span> <span class=n>one</span>
    <span class=k>if</span> <span class=n>there</span> <span class=n>are</span> <span class=n>one</span> <span class=n>or</span> <span class=n>more</span> <span class=n>threads</span> <span class=n>waiting</span><span class=p>,</span> <span class=n>wake</span> <span class=n>one</span>
<span class=p>}</span>
</code></pre></div> <h3 id=semaphore-as-a-lock>Semaphore as a lock<a class=headerlink href=#semaphore-as-a-lock title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=n>sem_t</span> <span class=n>m</span><span class=p>;</span>
<span class=n>sem_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>X</span><span class=p>);</span> <span class=c1>// initialize semaphore to X; what should X be?</span>
<span class=n>sem_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
<span class=c1>// critical section here</span>
<span class=n>sem_post</span><span class=p>(</span><span class=o>&amp;</span><span class=n>m</span><span class=p>);</span>
</code></pre></div> <h3 id=semaphores-as-conditional-variables>Semaphores as conditional variables<a class=headerlink href=#semaphores-as-conditional-variables title="Permanent link">&para;</a></h3> <ul> <li>Parent waiting for its child</li> <li>Producers and consumers</li> </ul> <p>TBD</p> <h2 id=deadlock>Deadlock<a class=headerlink href=#deadlock title="Permanent link">&para;</a></h2> <p>TBD</p> <h2 id=monitor>Monitor<a class=headerlink href=#monitor title="Permanent link">&para;</a></h2> <p>TBD</p> <h2 id=dining-philosophers-problem>Dining philosophers problem<a class=headerlink href=#dining-philosophers-problem title="Permanent link">&para;</a></h2> <p>TBD</p> <h2 id=applications>Applications<a class=headerlink href=#applications title="Permanent link">&para;</a></h2> <p>A timer is a child thread that wakes up periodically to check whether an expiration happened or not. The maximum number of timers is limited by the OS because many systems support a small number of concurrent threads. To implement arbitrary many timers using software, we can use a timer queue to reach the goal. Don't expect too much accuracy for this timer implementation, it is not. However, this approach is acceptable in most of the projects. A good reference is here[1]. source code.</p> <h2 id=reference>Reference<a class=headerlink href=#reference title="Permanent link">&para;</a></h2> <ul> <li><a href=http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf>Operating Systems: Three Easy Pieces</a></li> <li><a href=https://davejingtian.org/2013/09/28/timer-queue-a-way-to-handle-multiple-timers-using-one-thread/ >timer queue – a way to handle multiple timers using one thread</a></li> </ul> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../../ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Index </div> </div> </a> <a href=../../concepts/notes/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Distributed System Concepts </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Rui Han </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.77e55a48.min.js></script> <script src=../../../assets/javascripts/bundle.9554a270.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>