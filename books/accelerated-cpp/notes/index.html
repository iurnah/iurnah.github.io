<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><link href=https://ruihan.org/books/accelerated-cpp/notes/ rel=canonical><meta name=lang:clipboard.copy content="Copy to clipboard"><meta name=lang:clipboard.copied content="Copied to clipboard"><meta name=lang:search.language content=en><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No matching documents"><meta name=lang:search.result.one content="1 matching document"><meta name=lang:search.result.other content="# matching documents"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1, mkdocs-material-4.6.3"><title>Accelerated C++ - RUIHAN.ORG</title><link rel=stylesheet href=../../../assets/stylesheets/application.adb8469c.css><link rel=stylesheet href=../../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content><script src=../../../assets/javascripts/modernizr.86422ebf.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../../assets/fonts/material-icons.css></head> <body dir=ltr data-md-color-primary=black data-md-color-accent=black> <svg class=md-svg> <defs> <svg xmlns=http://www.w3.org/2000/svg width=416 height=448 viewbox="0 0 416 448" id=__github><path fill=currentColor d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#accelerated-c-reading-notes tabindex=0 class=md-skip> Skip to content </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://ruihan.org title=RUIHAN.ORG aria-label=RUIHAN.ORG class="md-header-nav__button md-logo"> <i class=md-icon></i> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> RUIHAN.ORG </span> <span class=md-header-nav__topic> Accelerated C++ </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search></label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input aria-label=search name=query placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=query data-md-state=active> <label class="md-icon md-search__icon" for=__search></label> <button type=reset class="md-icon md-search__icon" data-md-component=reset tabindex=-1> &#xE5CD; </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=result> <div class=md-search-result__meta> Type to start searching </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> </div> </div> </nav> </header> <div class=md-container> <nav class="md-tabs md-tabs--active" data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=./ class="md-tabs__link md-tabs__link--active"> Books </a> </li> <li class=md-tabs__item> <a href=../../../courses/cs224n/lec-notes/ class=md-tabs__link> Course Notes </a> </li> <li class=md-tabs__item> <a href=../../../leetcode/array/notes/ class=md-tabs__link> Leetcode </a> </li> <li class=md-tabs__item> <a href=../../../research/coalition-game/notes/ class=md-tabs__link> Research </a> </li> <li class=md-tabs__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ class=md-tabs__link> SEED Labs </a> </li> </ul> </div> </nav> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://ruihan.org title=RUIHAN.ORG class="md-nav__button md-logo"> <i class=md-icon></i> </a> RUIHAN.ORG </label> <div class=md-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-1 type=checkbox id=nav-1 checked> <label class=md-nav__link for=nav-1> Books </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-1> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-toggle md-nav__toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Accelerated C++ </label> <a href=./ title="Accelerated C++" class="md-nav__link md-nav__link--active"> Accelerated C++ </a> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#chapter-0 class=md-nav__link> Chapter 0 </a> </li> <li class=md-nav__item> <a href=#chapter-1 class=md-nav__link> Chapter 1 </a> </li> <li class=md-nav__item> <a href=#chapter-2 class=md-nav__link> Chapter 2 </a> </li> <li class=md-nav__item> <a href=#chapter-3 class=md-nav__link> Chapter 3 </a> </li> <li class=md-nav__item> <a href=#chapter-4-organize-program-h-and-cc-files-iostream-as-a-argument-exception-handling-basics class=md-nav__link> Chapter 4 (organize program .h and .cc files, iostream as a argument, exception handling basics) </a> </li> <li class=md-nav__item> <a href=#chapter-5-sequential-containers-vector-list-and-analyzing-strings class=md-nav__link> Chapter 5 (sequential containers (vector, list) and analyzing strings) </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51 class=md-nav__link> 5.1 </a> </li> <li class=md-nav__item> <a href=#52 class=md-nav__link> 5.2 </a> </li> <li class=md-nav__item> <a href=#55 class=md-nav__link> 5.5 </a> </li> <li class=md-nav__item> <a href=#58 class=md-nav__link> 5.8 </a> </li> <li class=md-nav__item> <a href=#notes class=md-nav__link> Notes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#chapter-6 class=md-nav__link> Chapter 6 </a> </li> <li class=md-nav__item> <a href=#chapter-7 class=md-nav__link> Chapter 7 </a> </li> <li class=md-nav__item> <a href=#chapter-8 class=md-nav__link> Chapter 8 </a> </li> <li class=md-nav__item> <a href=#chapter-9 class=md-nav__link> Chapter 9 </a> </li> <li class=md-nav__item> <a href=#chapter-10 class=md-nav__link> Chapter 10 </a> </li> <li class=md-nav__item> <a href=#chapter-11-implement-a-vector-class class=md-nav__link> Chapter 11 (Implement a vector class) </a> </li> <li class=md-nav__item> <a href=#chapter-12-making-class-objects-working-like-values class=md-nav__link> Chapter 12 (Making class objects working like values) </a> </li> <li class=md-nav__item> <a href=#chapter-13-inheritance class=md-nav__link> Chapter 13 (Inheritance) </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Course Notes </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-2> Course Notes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../courses/cs224n/lec-notes/ title="CS224N Lecture Notes" class=md-nav__link> CS224N Lecture Notes </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/write-up/ title="CS224N Write-up" class=md-nav__link> CS224N Write-up </a> </li> <li class=md-nav__item> <a href=../../../courses/6.431-probability/notes/ title="6.431 Probability" class=md-nav__link> 6.431 Probability </a> </li> <li class=md-nav__item> <a href=../../../courses/func-prog-in-scala/notes/ title="Func Prog Principles in Scala" class=md-nav__link> Func Prog Principles in Scala </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-dynamic-prog/notes/ title="Nine Chapter Dynamic Prog" class=md-nav__link> Nine Chapter Dynamic Prog </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-3 type=checkbox id=nav-3> <label class=md-nav__link for=nav-3> Leetcode </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-3> Leetcode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../leetcode/array/notes/ title=Array class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../../leetcode/binary-search/notes/ title="Binary Search" class=md-nav__link> Binary Search </a> </li> <li class=md-nav__item> <a href=../../../leetcode/backtracking/notes/ title=Backtracking class=md-nav__link> Backtracking </a> </li> <li class=md-nav__item> <a href=../../../leetcode/dynamic-programming/notes/ title="Dynamic Programming" class=md-nav__link> Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../leetcode/heap/notes/ title=Heap class=md-nav__link> Heap </a> </li> <li class=md-nav__item> <a href=../../../leetcode/string/notes/ title=String class=md-nav__link> String </a> </li> <li class=md-nav__item> <a href=../../../leetcode/union-find/notes/ title="Union Find" class=md-nav__link> Union Find </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Research </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-4> Research </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../research/coalition-game/notes/ title="Coalition Game" class=md-nav__link> Coalition Game </a> </li> <li class=md-nav__item> <a href=../../../research/contextual-bandit/notes/ title="Contextual Multi-Armed Bandit" class=md-nav__link> Contextual Multi-Armed Bandit </a> </li> <li class=md-nav__item> <a href=../../../research/tfidf-score/notes/ title="TF-IDF for Information Retrieval" class=md-nav__link> TF-IDF for Information Retrieval </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-toggle md-nav__toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> SEED Labs </label> <nav class=md-nav data-md-component=collapsible data-md-level=1> <label class=md-nav__title for=nav-5> SEED Labs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ title="Public Key Cryptography and PKI" class=md-nav__link> Public Key Cryptography and PKI </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#chapter-0 class=md-nav__link> Chapter 0 </a> </li> <li class=md-nav__item> <a href=#chapter-1 class=md-nav__link> Chapter 1 </a> </li> <li class=md-nav__item> <a href=#chapter-2 class=md-nav__link> Chapter 2 </a> </li> <li class=md-nav__item> <a href=#chapter-3 class=md-nav__link> Chapter 3 </a> </li> <li class=md-nav__item> <a href=#chapter-4-organize-program-h-and-cc-files-iostream-as-a-argument-exception-handling-basics class=md-nav__link> Chapter 4 (organize program .h and .cc files, iostream as a argument, exception handling basics) </a> </li> <li class=md-nav__item> <a href=#chapter-5-sequential-containers-vector-list-and-analyzing-strings class=md-nav__link> Chapter 5 (sequential containers (vector, list) and analyzing strings) </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#51 class=md-nav__link> 5.1 </a> </li> <li class=md-nav__item> <a href=#52 class=md-nav__link> 5.2 </a> </li> <li class=md-nav__item> <a href=#55 class=md-nav__link> 5.5 </a> </li> <li class=md-nav__item> <a href=#58 class=md-nav__link> 5.8 </a> </li> <li class=md-nav__item> <a href=#notes class=md-nav__link> Notes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#chapter-6 class=md-nav__link> Chapter 6 </a> </li> <li class=md-nav__item> <a href=#chapter-7 class=md-nav__link> Chapter 7 </a> </li> <li class=md-nav__item> <a href=#chapter-8 class=md-nav__link> Chapter 8 </a> </li> <li class=md-nav__item> <a href=#chapter-9 class=md-nav__link> Chapter 9 </a> </li> <li class=md-nav__item> <a href=#chapter-10 class=md-nav__link> Chapter 10 </a> </li> <li class=md-nav__item> <a href=#chapter-11-implement-a-vector-class class=md-nav__link> Chapter 11 (Implement a vector class) </a> </li> <li class=md-nav__item> <a href=#chapter-12-making-class-objects-working-like-values class=md-nav__link> Chapter 12 (Making class objects working like values) </a> </li> <li class=md-nav__item> <a href=#chapter-13-inheritance class=md-nav__link> Chapter 13 (Inheritance) </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=accelerated-c-reading-notes>Accelerated C++ Reading Notes<a class=headerlink href=#accelerated-c-reading-notes title="Permanent link">&para;</a></h1> <h2 id=chapter-0>Chapter 0<a class=headerlink href=#chapter-0 title="Permanent link">&para;</a></h2> <ol> <li>Expression -&gt; results + side effects</li> <li>Every operand has a type <code>std::out</code> has type <code>std::ostream</code></li> <li><code>&lt;&lt;</code> is left-associative, mean: <code>(std::cout &lt;&lt; "Hello, world!") &lt;&lt; std::endl</code></li> <li><code>int main(){}</code> return 0 if return sccessful, otherwise return failure.</li> <li>exercise 0-7 tell us comments like this wouldn't work <code>/*comments1 /*comment2*/comment3*/</code> is illigle.</li> <li> <p>exercise 0-8 tell us comments like this would work fine</p> <div class=codehilite><pre><span></span><code><span class=c1>// This is a comment that extends over several lines</span>
<span class=c1>// by using // at the beginning of each line instead of using /*</span>
<span class=c1>// or */ to delimit comments.</span>
</code></pre></div> </li> </ol> <h2 id=chapter-1>Chapter 1<a class=headerlink href=#chapter-1 title="Permanent link">&para;</a></h2> <ol> <li><code>&gt;&gt;</code> begins by discarding whitespace chars (space, tab, backspace, or the end of line) from the input, then reads chars into a virable until it encounters another whitespace character or end-of-file.</li> <li>input-output library saves its output in an internal data structure called a buffer, which it uses to optimize output operations. it use the buffer to accumulate the characters to be written, and flushes the buffer, only when necessary.</li> <li>3 events cause the flush:<ol> <li>when it is full;</li> <li>when it is asked to read from the std input;</li> <li>when we explicitly say to do so;</li> </ol> </li> <li>How to print a framed string?</li> <li>std::string constructor: <code>const std::string greeting(greeting.size(), ' ')</code> will generate a whitespace string with length of greeting.size().</li> <li>character literal should be enclosed by <code>' '</code>, string literal should be enclosed by <code>" "</code>.</li> <li>Built-in type <code>char</code> and <code>wchar_t</code>, which is big enough for holding characters for languages such as Chinese.</li> </ol> <h2 id=chapter-2>Chapter 2<a class=headerlink href=#chapter-2 title="Permanent link">&para;</a></h2> <ol> <li><code>while</code> statement, <strong>loop invariant</strong>: which is a property that we assert will be true about a while each time it is about to test its condition. i.e. <em>write r line so far</em></li> </ol> <div class=codehilite><pre><span></span><code><span class=c1>// invariant: we have written r rows so far</span>
<span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
<span class=c1>// setting r to 0 makes the invariant true</span>
<span class=k>while</span> <span class=p>(</span><span class=n>r</span> <span class=o>!=</span> <span class=n>rows</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// we can assume that the invariant is true here</span>
    <span class=c1>// writing a row of output makes the invariant false</span>
    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
    <span class=c1>// incrementing r makes the invariant true again</span>
    <span class=o>++</span><span class=n>r</span><span class=p>;</span>
<span class=p>}</span>
<span class=c1>// we can conclude that the invariant is true here The</span>
</code></pre></div> <ol> <li><code>std::string::size_type</code> type for strings length or . This is to protect the int from being overflow if we have an arbitrary long input.</li> <li>Asymmetric range [n, m) is better then a symmetric range [n, m]. always start the range with 0 such as [0, n)<ol> <li><code>[n, m)</code> have <code>m-n</code> elements, <code>[n, m]</code> have <code>m-n+1</code> elements.</li> <li>empty range i.e. <code>[n,n)</code>.</li> </ol> </li> <li>modulo operation equivalent : <code>x % y &lt;==&gt; x - ((x/y) * y)</code></li> <li>pay attention to the problem 2-4, adding code to ensure the invariant for outer while.</li> </ol> <h2 id=chapter-3>Chapter 3<a class=headerlink href=#chapter-3 title="Permanent link">&para;</a></h2> <ol> <li>double is even faster than float, double has at least 15 significant digits. float has at least 6 digits.</li> <li><code>while(cin &gt;&gt; x)</code> is equal to <code>cin &gt;&gt; x; while(cin)</code>, because <code>&gt;&gt;</code> operator return its left operand</li> <li><code>streamsize prec = cout.pecision();</code> and manipulator <code>setprecision(3)</code> ==&gt; 56.5 or 5.65</li> <li><code>std::vector&lt;double&gt;::size_type</code> is analogous to the one in <code>string::size_type</code></li> <li>sort function in <code>&lt;algorithm&gt;</code> header prototype: <code>sort(homework.begin(), homework.end())</code>, <strong>sort in place</strong></li> <li>vector class provide two member functions: <code>begin()</code> and <code>end()</code></li> <li>calculate the median of a sorted vector homework: <div class=codehilite><pre><span></span><code><span class=n>vec_sz</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>size</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>
<span class=kt>double</span> <span class=n>median</span><span class=p>;</span>
<span class=n>median</span> <span class=o>=</span> <span class=n>size</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=p>(</span><span class=n>homework</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>+</span> <span class=n>homework</span><span class=p>[</span><span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>:</span> <span class=n>homework</span><span class=p>[</span><span class=n>mid</span><span class=p>];</span>
</code></pre></div></li> <li><code>vec.end()</code> return a value that denotes one past the last elelment in v.</li> <li><code>streamsize</code> The type of the value expected by <code>setprecision()</code> and returned by <code>precision()</code>. Defined in <code>&lt;ios&gt;</code>.</li> <li>The return value of the <code>vector&lt;int&gt;::type_size</code> is unsigned integral number. Doing operation with it could not possibly generate negative value, i.e. if <code>vec.size()</code> is 5, <code>vec.size() - 6</code> is not negative, it will be positive.</li> </ol> <h2 id=chapter-4-organize-program-h-and-cc-files-iostream-as-a-argument-exception-handling-basics>Chapter 4 (organize program <code>.h</code> and <code>.cc</code> files, iostream as a argument, exception handling basics)<a class=headerlink href=#chapter-4-organize-program-h-and-cc-files-iostream-as-a-argument-exception-handling-basics title="Permanent link">&para;</a></h2> <ol> <li>When a program throws an exception, the program stop at the part of the program in which the <code>throw</code> appears. appears, and passes to another part of the program, along with an <strong>exception object</strong>, which contains information that the caller can use to act on the exception.</li> <li>Domain error: <code>throw domain_error("median of an empty vector")</code>; Defined in <code>&lt;stdexcept&gt;</code>, it is used in reporting that a function's argument is outside the set of values that the function can accept.<ol> <li>domain error is one of logic_error in <stdexcept>, there are other type of exception: runtime_error, which includes <code>overflow_error</code>, <code>underflow_error</code>, etc. <a href=http://www.cplusplus.com/reference/stdexcept/runtime_error/ >ref:runtime_error</a>.</li> </ol> </li> <li>const means we will promise not modify the variable. <code>&amp;</code> means a reference or an alias. i.e. <div class=codehilite><pre><span></span><code><span class=n>vector</span><span class=o>&lt;</span><span class=n>doubel</span><span class=o>&gt;</span> <span class=n>homework</span><span class=p>;</span>
<span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>doubel</span><span class=o>&gt;&amp;</span> <span class=n>chw</span> <span class=o>=</span> <span class=n>homework</span><span class=p>;</span> <span class=c1>//chw is a synonym for homework</span>
</code></pre></div></li> <li>reference to reference is the same as reference to the original variable.</li> <li>when define non const reference, we have to make sure the original variable or reference isn't a const. otherwise, it will be illigel. i.e. with above definition, we cannot do this <code>vector&lt;doubel&gt;&amp; hw2=chw;</code></li> <li>a const argument could take a const parameter.</li> <li>iostream as a parameter to a function: (alwasy keep in mind that a iostream is a type, it has other properties such as vector or int have.) <div class=codehilite><pre><span></span><code><span class=n>istream</span><span class=o>&amp;</span> <span class=n>read_hw</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>in</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>hw</span><span class=p>){}</span>
</code></pre></div></li> <li>__lvalue: __We must pass an lvalue argument to a reference parameter. An lvalue is a value that denotes a nontemporary object. For example, a variable is an lvalue, as is a reference, or the result of calling a function that returns a reference. An expression that generates an arithmetic value, such as sum / count, is not an lvalue.</li> <li><code>clear()</code> member functions for istream. This is to ensure the eof or non-valid input data will not effect reading the next data. __Alwasy run cin.clear(), before we try to read again.</li> <li>pass by value: <code>vector&lt;double&gt; vec</code>: this will copy the argument, the original will not be modified.</li> <li>pass by reference: <code>vector&lt;double&gt;&amp; vec</code>: this will <strong>not</strong> copy the argument, but will modify the original argument. This is good convention for object as a parameter, because copying will introduce overhead.</li> <li>pass by const reference: <code>const vector&lt;double&gt;&amp; vec</code>: this will <strong>not</strong> copy the argument as well as <em>promise</em> not to modify the passed argument. </li> <li> <p><code>try {} catch {}</code> clause, we normally break down to multiple statements in the try clause, because we want to avoid multiple side effect. For example, <div class=codehilite><pre><span></span><code><span class=k>try</span> <span class=p>{</span>
        <span class=kt>double</span> <span class=n>final_grade</span> <span class=o>=</span> <span class=n>grade</span><span class=p>(</span><span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>,</span> <span class=n>homework</span><span class=p>);</span>
        <span class=n>streamsize</span> <span class=n>prec</span> <span class=o>=</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Your final grade is &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
            <span class=o>&lt;&lt;</span> <span class=n>final_grade</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=n>prec</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>domain_error</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;You must enter your grades. &quot;</span>
        <span class=s>&quot;Please try again.&quot;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> is better then written as <div class=codehilite><pre><span></span><code><span class=k>try</span> <span class=p>{</span>
        <span class=n>streamsize</span> <span class=n>prec</span> <span class=o>=</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Your final grade is &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
                <span class=o>&lt;&lt;</span> <span class=n>grade</span><span class=p>(</span><span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>,</span> <span class=n>homework</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=n>prec</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> because the later can generate ambigious error message that not easy to debug.</p> </li> <li> <p>sort object <code>Student_info</code>, we have to use another form of <code>sort(student.begin(), students.end())</code> with a extra parameter, which is a predicate to compare the two object. i.e. <div class=codehilite><pre><span></span><code><span class=kt>bool</span> <span class=nf>compare</span><span class=p>(</span><span class=k>const</span> <span class=n>Student_info</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>,</span> <span class=n>cosnt</span> <span class=n>Student_info</span><span class=o>&amp;</span> <span class=n>y</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>x</span><span class=p>.</span><span class=n>name</span> <span class=o>&lt;</span> <span class=n>y</span><span class=p>.</span><span class=n>name</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>sort</span><span class=p>(</span><span class=n>students</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=n>students</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>compare</span><span class=p>);</span>
</code></pre></div></p> </li> <li>Formatting the output, if we want to do the following <div class=codehilite><pre><span></span><code><span class=err>Bob         88</span>
<span class=err>Christopher 90</span>
</code></pre></div> we could do this: <div class=codehilite><pre><span></span><code><span class=n>maxlen</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>maxlen</span><span class=p>,</span> <span class=n>record</span><span class=p>.</span><span class=n>name</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>students</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>string</span><span class=p>(</span><span class=n>maxlen</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>students</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>name</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=sc>&#39; &#39;</span><span class=p>);</span>
</code></pre></div> Notice the string(num, ' '); instantiate a string has num of spaces.</li> <li>The example program from this chapter is worth of keeping here for references. There is a lot information included in it. <div class=codehilite><pre><span></span><code><span class=c1>//Calculate the grade for many students, including reading the data in, </span>
<span class=c1>//how to sort according there name and how to format the out put in a nice printing, ect.</span>
<span class=cp>#include</span> <span class=cpf>&lt;algorithm&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;iomanip&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;stdexcept&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;string&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp></span>

<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>domain_error</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>istream</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>setprecision</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>streamsize</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=p>;</span>
<span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=p>;</span>

<span class=c1>// compute the median of a `vector&lt;double&gt;&#39;</span>
<span class=c1>// note that calling this function copies the entire argument `vector&#39;</span>
<span class=kt>double</span> <span class=nf>median</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>)</span> <span class=p>{</span>
<span class=cp>#ifdef _MSC_VER</span>
    <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>size_type</span> <span class=n>vec_sz</span><span class=p>;</span>
<span class=cp>#else</span>
    <span class=k>typedef</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;::</span><span class=n>size_type</span> <span class=n>vec_sz</span><span class=p>;</span>
<span class=cp>#endif</span>

    <span class=n>vec_sz</span> <span class=n>size</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
    <span class=k>throw</span> <span class=n>domain_error</span><span class=p>(</span><span class=s>&quot;median of an empty vector&quot;</span><span class=p>);</span>

    <span class=n>sort</span><span class=p>(</span><span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>

    <span class=n>vec_sz</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>size</span><span class=o>/</span><span class=mi>2</span><span class=p>;</span>

    <span class=k>return</span> <span class=n>size</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=p>(</span><span class=n>vec</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>+</span> <span class=n>vec</span><span class=p>[</span><span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>:</span> <span class=n>vec</span><span class=p>[</span><span class=n>mid</span><span class=p>];</span>
<span class=p>}</span>

<span class=c1>// compute a student&#39;s overall grade from midterm and final exam grades and homework grade</span>
<span class=kt>double</span> <span class=nf>grade</span><span class=p>(</span><span class=kt>double</span> <span class=n>midterm</span><span class=p>,</span> <span class=kt>double</span> <span class=k>final</span><span class=p>,</span> <span class=kt>double</span> <span class=n>homework</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mf>0.2</span> <span class=o>*</span> <span class=n>midterm</span> <span class=o>+</span> <span class=mf>0.4</span> <span class=o>*</span> <span class=k>final</span> <span class=o>+</span> <span class=mf>0.4</span> <span class=o>*</span> <span class=n>homework</span><span class=p>;</span>
<span class=p>}</span>

<span class=c1>// compute a student&#39;s overall grade from midterm and final exam grades</span>
<span class=c1>// and vector of homework grades.</span>
<span class=c1>// this function does not copy its argument, because `median&#39; does so for us.</span>
<span class=kt>double</span> <span class=nf>grade</span><span class=p>(</span><span class=kt>double</span> <span class=n>midterm</span><span class=p>,</span> <span class=kt>double</span> <span class=k>final</span><span class=p>,</span> <span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>hw</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>hw</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
    <span class=k>throw</span> <span class=n>domain_error</span><span class=p>(</span><span class=s>&quot;student has done no homework&quot;</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>grade</span><span class=p>(</span><span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>,</span> <span class=n>median</span><span class=p>(</span><span class=n>hw</span><span class=p>));</span>
<span class=p>}</span>

<span class=c1>// read homework grades from an input stream into a `vector&lt;double&gt;&#39;</span>
<span class=n>istream</span><span class=o>&amp;</span> <span class=n>read_hw</span><span class=p>(</span><span class=n>istream</span><span class=o>&amp;</span> <span class=n>in</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;&amp;</span> <span class=n>hw</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>in</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// get rid of previous contents</span>
    <span class=n>hw</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>

    <span class=c1>// read homework grades</span>
    <span class=kt>double</span> <span class=n>x</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>in</span> <span class=o>&gt;&gt;</span> <span class=n>x</span><span class=p>)</span>
        <span class=n>hw</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>

    <span class=c1>// clear the stream so that input will work for the next student</span>
    <span class=n>in</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>in</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// ask for and read the student&#39;s name</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Please enter your first name: &quot;</span><span class=p>;</span>
    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>name</span><span class=p>;</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Hello, &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;!&quot;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>

    <span class=c1>// ask for and read the midterm and final grades</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Please enter your midterm and final exam grades: &quot;</span><span class=p>;</span>
    <span class=kt>double</span> <span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>;</span>
    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>midterm</span> <span class=o>&gt;&gt;</span> <span class=k>final</span><span class=p>;</span>

    <span class=c1>// ask for the homework grades</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Enter all your homework grades, &quot;</span>
    <span class=s>&quot;followed by end-of-file: &quot;</span><span class=p>;</span>

    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span> <span class=n>homework</span><span class=p>;</span>

    <span class=c1>// read the homework grades</span>
    <span class=n>read_hw</span><span class=p>(</span><span class=n>cin</span><span class=p>,</span> <span class=n>homework</span><span class=p>);</span>

    <span class=c1>// compute and generate the final grade, if possible</span>
    <span class=k>try</span> <span class=p>{</span>
    <span class=kt>double</span> <span class=n>final_grade</span> <span class=o>=</span> <span class=n>grade</span><span class=p>(</span><span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>,</span> <span class=n>homework</span><span class=p>);</span>
    <span class=n>streamsize</span> <span class=n>prec</span> <span class=o>=</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;Your final grade is &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
        <span class=o>&lt;&lt;</span> <span class=n>final_grade</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=n>prec</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>domain_error</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;You must enter your grades.  &quot;</span>
        <span class=s>&quot;Please try again.&quot;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li> <li>hearder file should declare only the names that are necessary. Header files should use fully qualified names rather than using-declarations. (Avoid <code>using namespace std</code>;) <div class=codehilite><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp></span>
<span class=kt>double</span> <span class=nf>median</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>double</span><span class=o>&gt;</span><span class=p>);</span>
</code></pre></div></li> <li>Avoid multiple inclusion <div class=codehilite><pre><span></span><code><span class=cp>#ifndef __THIS_HEADER_H__</span>
<span class=cp>#define __THIS_HEADER_H__</span>
<span class=c1>//your program</span>
<span class=cp>#endif</span>
</code></pre></div></li> <li> <p>type of exceptions</p> <table> <thead> <tr> <th>logic_error</th> <th>domain_error</th> </tr> </thead> <tbody> <tr> <td>length_error</td> <td>out_of_range</td> </tr> <tr> <td>invalid_argument</td> <td>runtime_error</td> </tr> <tr> <td>range_error</td> <td>overflow_error</td> </tr> <tr> <td>underflow_error</td> <td></td> </tr> </tbody> </table> </li> <li> <p>exceptional handling <div class=codehilite><pre><span></span><code><span class=k>try</span> <span class=p>{</span>
        <span class=c1>// code Initiates a block that might throw an exception.</span>
<span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>t</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// code</span>
<span class=p>}</span>

<span class=c1>//real use case.</span>
<span class=k>try</span> <span class=p>{</span>
        <span class=kt>double</span> <span class=n>final_grade</span> <span class=o>=</span> <span class=n>grade</span><span class=p>(</span><span class=n>students</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=n>streamsize</span> <span class=n>prec</span> <span class=o>=</span> <span class=n>cout</span><span class=p>.</span><span class=n>precision</span><span class=p>();</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>final_grade</span>
            <span class=o>&lt;&lt;</span> <span class=n>setprecision</span><span class=p>(</span><span class=n>prec</span><span class=p>);</span>
<span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=n>domain_error</span> <span class=n>e</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>what</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div> Concludes the <code>try</code> block and handles exceptions that match the type <code>t</code>. The code following the <code>catch</code> performs whatever action is appropriate to handle the exception reported in <code>t</code>.</p> </li> <li><code>throw e</code>; Terminates the current function; throws the value e back to the caller.</li> <li><code>e.what()</code>: return a value that report on what happened to cause the error.</li> <li><code>str.width([n])</code> and <code>std::setw(n)</code> both used to set the output width.</li> </ol> <h2 id=chapter-5-sequential-containers-vector-list-and-analyzing-strings>Chapter 5 (sequential containers (vector, list) and analyzing strings)<a class=headerlink href=#chapter-5-sequential-containers-vector-list-and-analyzing-strings title="Permanent link">&para;</a></h2> <h3 id=51>5.1<a class=headerlink href=#51 title="Permanent link">&para;</a></h3> <p>write a function <code>extract_fails()</code> to seperate the students that failed the course. The ideas is to use two seperate vector to hold the ones that passed and the ones that failed. To make it better, we only use one vector <code>fails</code> to hold the failed students, and erase them from the original vector. however, be cautions in using the <code>erase</code> memeber function for vectors. 1. the indexes of element after the removed element will change. 2. the size will change. 3. efficiency problem.</p> <p>Introduced the necessity of using <code>iterator</code>. Briefly, it is for efficiency optimization. The indexing is random access, which is more expensive to maintain the data structure properties, such as for vector. <code>iterator</code> allow us to separate the data access manner (sequential v.s. random) in a container, so as to implement different container to cope with a different need. All this work is because of efficiency concerns.</p> <h3 id=52>5.2<a class=headerlink href=#52 title="Permanent link">&para;</a></h3> <p>Beside providing access or modify operations, a iterator is able to restrict the available operations in ways that correspond to what the iterator can handle efficiently. Generally, two type of iterators: <code>const_iterator</code> and <code>iterator</code>. when we do <code>vector&lt;student&gt;::const_iterator iter = S.begin()</code>, there is an explicit type conversion happened because <code>S.begin()</code> is a type of <code>iterator</code>.</p> <p>The usage of iterator <code>vector&lt;int&gt;::iterator iter;</code>, either <code>iter-&gt;name</code> or <code>(*iter).name</code>.</p> <h3 id=55>5.5<a class=headerlink href=#55 title="Permanent link">&para;</a></h3> <p>vector and list differ in that if you call <code>erase(iter)</code> member function of the container. vector will invalidate all the iterators following iter in the vector. Even this is the case, we can use <code>erase</code> to delete a element from the container. i.e. <code>iter = students.erase(iter);</code>, <code>iter</code> will point to the next element of the removed element.</p> <p>Similarly, call <code>push_back</code> member function will invalidate all the iters of the vector. while for list container, call <code>erase(iter)</code> only invalidate the <code>iter</code> erased, not others. and call <code>push_back</code> will not invalidate other iterators.</p> <p>Because list doesn't support random access. We cannot use the <code>sort()</code> function from <code>&lt;algorithm&gt;</code>. Instead we have to use the member function that optimized for list container.</p> <h3 id=58>5.8<a class=headerlink href=#58 title="Permanent link">&para;</a></h3> <p>Use <code>inset</code> function to do vertical concatenation <code>ret.insert(ret.end(), bottom.begin(), bottom.end())</code></p> <h3 id=notes>Notes<a class=headerlink href=#notes title="Permanent link">&para;</a></h3> <ol> <li><code>students.erase(students.begin()+i)</code>, remove the ith object in the container <code>students</code>.</li> <li> <p><code>iterator</code> properties:</p> <ol> <li>Identifies a container and an element in the container</li> <li>Lets us examine the value stored in that element</li> <li>Provides operations for moving between elements in the container</li> <li>Restricts the available operations in ways that correspond to what the container can handle efficiently</li> </ol> </li> <li> <p><code>iterator</code> types:</p> <ol> <li><code>container-type::iterator</code>: to change the container value</li> <li><code>container-type::const_iterator</code>: to only read the container value</li> <li><code>container-type::reverse_iterator</code></li> <li><code>container-type::const_reverse_iterator</code></li> </ol> </li> <li><code>*iter</code> return a lvalue. we can replace <code>(*iter).name</code> with <code>iter-&gt;name</code></li> <li><code>students.erase(iter)</code> will invalidate all the iterators following the elements that has been removed. After <code>iter = students.erase(iter)</code>, <code>iter</code> will point to the first element following the removed element.</li> <li> <p>From <code>vector</code> to <code>list</code>.</p> <table> <thead> <tr> <th>vector</th> <th>list</th> </tr> </thead> <tbody> <tr> <td>optimized for fast <strong>random access</strong></td> <td>optimized for fast insertion and deletion</td> </tr> <tr> <td>Using <code>push_back</code> to append an element to a vector <strong>invalidates</strong> all iterators referring to that vector.</td> <td>the <code>erase</code> and <code>push_back</code> operations do not invalidate iterators to other elements.</td> </tr> </tbody> </table> </li> <li> <p><code>list</code>: doesn't support random access, so the STL <code>&lt;algorithm&gt;</code> library function <code>sort()</code> doens't apply to <code>list</code></p> </li> <li><code>string</code> example, split a sentence into words. <div class=codehilite><pre><span></span><code><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>split</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>ret</span><span class=p>;</span>
    <span class=k>typedef</span> <span class=n>string</span><span class=o>::</span><span class=n>size_type</span> <span class=n>string_size</span><span class=p>;</span> <span class=n>string_size</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// invariant: we have processed characters [original value of i, i)</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// ignore leading blanks</span>
        <span class=c1>// invariant: characters in range [original i, current i) are all spaces</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>isspace</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]))</span>
            <span class=o>++</span><span class=n>i</span><span class=p>;</span>

        <span class=c1>// find end of next word string_size</span>
        <span class=n>string_size</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
       <span class=c1>// invariant: none of the characters in range [original j, current j)is a space</span>
        <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>!=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>isspace</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>]))</span>
            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
        <span class=c1>// if we found some nonwhitespace characters</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>j</span><span class=p>){</span>
            <span class=c1>// copy from s starting at i and taking j - i chars</span>
            <span class=n>ret</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>-</span> <span class=n>i</span><span class=p>));</span>
                <span class=n>i</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li> <li><code>isspace</code> is in the header file <code>&lt;cctype&gt;</code><ol> <li><code>isspace(c)</code> true if c is a whitespace character.</li> <li><code>isalpha(c)</code> true if c is an alphabetic character.</li> <li><code>isdigit(c)</code> true if c is a digit character.</li> <li><code>isalnum(c)</code> true if c is a letter or a digit.</li> <li><code>ispunct(c)</code> true if c is a punctuation character.</li> <li><code>isupper(c)</code> true if c is an uppercase letter.</li> <li><code>islower(c)</code> true if c is a lowercase letter.</li> <li><code>toupper(c)</code> Yields the uppercase equivalent to c</li> <li><code>tolower(c)</code> Yields the lowercase equivalent to c</li> </ol> </li> <li>In the <code>ret.push_back(s.str(i, j-i))</code>, the <code>j-i</code> indicate a open range <code>[s[i], s[j])</code></li> <li><code>while (cin &gt;&gt; s)</code> is read one work at a time, because the <code>std::cin</code> seperated by white spaces. It terminate until a invalid input is entered or a EOF.</li> <li><code>while (getline(cin, s))</code> is reading one line at a time, it return false when EOF entered or invalid chars.</li> <li>How to framing a word characters.</li> <li>How to cancatenate two vector?,<ol> <li>we can do <code>insert(ret.end(), bottom.begin(), bottom.end())</code>, note the first argument provide the iterator <strong>before which</strong> the element will be inserted.</li> </ol> </li> <li>How to concatenate two pictures horizontally like the bellow <div class=codehilite><pre><span></span><code><span class=err>pictures in case 1:</span>
<span class=err>this is an   **************</span>
<span class=err>example     * this is an * </span>
<span class=err>to           * example    *</span>
<span class=err>illustrate   * to        *</span>
<span class=err>framing       * illustrate * </span>
<span class=err>               * framing    *</span>
<span class=err>               **************</span>
<span class=err>pictures in case 2:</span>
<span class=err>************** this is an</span>
<span class=err>* this is an * example</span>
<span class=err>* example    * to</span>
<span class=err>* to         * illustrate</span>
<span class=err>* illustrate * framing</span>
<span class=err>* framing    * </span>
<span class=err>**************</span>
</code></pre></div> <div class=codehilite><pre><span></span><code><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>hcat</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>left</span><span class=p>,</span> <span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>right</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>ret</span><span class=p>;</span>
    <span class=c1>// add 1 to leave a space between pictures</span>
    <span class=n>string</span><span class=o>::</span><span class=n>size_type</span> <span class=n>width1</span> <span class=o>=</span> <span class=n>width</span><span class=p>(</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
    <span class=c1>// indices to look at elements from left and right respectively</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;::</span><span class=n>size_type</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=c1>// continue until we&#39;ve seen all rows from both pictures</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>left</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>||</span> <span class=n>j</span> <span class=o>!=</span> <span class=n>right</span><span class=p>.</span><span class=n>size</span><span class=p>())</span> <span class=p>{</span>
        <span class=c1>// construct new string to hold characters from both pictures</span>
        <span class=n>string</span> <span class=n>s</span><span class=p>;</span>
        <span class=c1>// copy a row from the left-hand side, if there is one</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>left</span><span class=p>.</span><span class=n>size</span><span class=p>())</span>
            <span class=n>s</span> <span class=o>=</span> <span class=n>left</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>];</span>

        <span class=c1>// pad to full width</span>
        <span class=n>s</span> <span class=o>+=</span> <span class=n>string</span><span class=p>(</span><span class=n>width1</span> <span class=o>-</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=sc>&#39; &#39;</span><span class=p>);</span>

        <span class=c1>// copy a row from the right-hand side, if there is one</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>!=</span> <span class=n>right</span><span class=p>.</span><span class=n>size</span><span class=p>())</span>
            <span class=n>s</span> <span class=o>+=</span> <span class=n>right</span><span class=p>[</span><span class=n>j</span><span class=o>++</span><span class=p>];</span>

        <span class=c1>// add s to the picture we&#39;re creating</span>
        <span class=n>ret</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li> <li><code>vec.reserve(n)</code>: Reserves space to hold n elements, but does not initialize them. This operation does not change the size of the container. It affects only the frequency with which vector may have to allocate memory in response to repeated calls to insert or push_back.</li> <li><code>c.rbegin()</code> and <code>c.rend()</code> are iterator refering to the last and (one beyond) the first element in the container that grant access to the container's elements in reverse order.</li> </ol> <h2 id=chapter-6>Chapter 6<a class=headerlink href=#chapter-6 title="Permanent link">&para;</a></h2> <h2 id=chapter-7>Chapter 7<a class=headerlink href=#chapter-7 title="Permanent link">&para;</a></h2> <h2 id=chapter-8>Chapter 8<a class=headerlink href=#chapter-8 title="Permanent link">&para;</a></h2> <ol> <li>The language feature that implements generic functions is called template functions.</li> <li>template header <code>template&lt;class T&gt;</code></li> <li><strong>"instantiation"</strong></li> <li>Keyword <code>typename</code>, i.e. <code>typedef typename vector&lt;T&gt;::size_type vec_sz;</code> "you must precede the entire name by <code>typename</code> to let the implementation know to treat the name as a type."</li> <li> <p>The C++ standard says nothing about how implementations should manage template instantiation, so every implementation handles instantiation in its own particular way. While we cannot say exactly how your compiler will handle instantiation, there are two important points to keep in mind: The first is that for C++ implementations that follow the traditional edit-compile-link model, instantiation often happens not at compile time, but at link time. It is not until the templates are instantiated that the implementation can verify that the template code can be used with the types that were specified. Hence, it is possible to get what seem like compile-time errors at link time. The second point matters if you write your own templates: Most current implementations require that in order to instantiate a template, the definition of the template, not just the declaration, has to be accessible to the implementation. Generally, this requirement implies access to the source files that define the template, as well as the header file. How the implementation locates the source file differs from one implementation to another. Many implementations expect the header file for the template to include the source file, either directly or via a #include. The most certain way to know what your implementation expects is to check its documentation.</p> </li> <li> <p>parameter type to a generic function should keep consistent. For example, We cannot pass int and double to the following function: <div class=codehilite><pre><span></span><code><span class=n>tmeplate</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
<span class=n>T</span> <span class=n>max</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>left</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>right</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>left</span> <span class=o>&gt;</span> <span class=n>right</span> <span class=o>?</span> <span class=nl>left</span> <span class=p>:</span> <span class=n>right</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></p> </li> <li>Data structure indepnedence: why we write the find function as <code>find(c.begin(), c.end(), val)</code>? (it is the only way to write generic functions that works on more than 1 element types)</li> <li>Why not write as the form <code>c.find(val)</code> or <code>find(c, val)</code>?</li> <li> <p>iterator categories:</p> <p>1.Sequential read-only access (input iterator) 2.Sequential write-only access (output iterator) 3.Sequentila read-wirte access (input-output iterator) 4.Reverseible access 5.Random access</p> </li> <li> <p>"input iterator" - interator support "++, ==, !=, unary *, and it-&gt;first". We say we give <code>find</code> two input iterators as parameters. <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>In</span><span class=p>,</span> <span class=k>class</span> <span class=nc>X</span><span class=o>&gt;</span>
<span class=n>In</span> <span class=n>find</span><span class=p>(</span><span class=n>In</span> <span class=n>begin</span><span class=p>,</span> <span class=n>In</span> <span class=n>end</span><span class=p>,</span> <span class=n>constX</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=n>begin</span> <span class=o>==</span> <span class=n>end</span> <span class=o>||</span> <span class=o>*</span><span class=n>begin</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span>
        <span class=k>return</span><span class=p>;</span>

    <span class=n>begin</span><span class=o>++</span><span class=p>;</span>
    <span class=k>return</span> <span class=nf>find</span><span class=p>(</span><span class=n>begin</span><span class=p>,</span> <span class=n>end</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></p> </li> <li>"output iterator" -interator support <code>*dest = _value_, dest++, and ++dest</code> <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>In</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Out</span><span class=o>&gt;</span>
<span class=n>Out</span> <span class=n>copy</span><span class=p>(</span><span class=n>In</span> <span class=n>begin</span><span class=p>,</span> <span class=n>In</span> <span class=n>end</span><span class=p>,</span> <span class=n>Out</span> <span class=n>dest</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>begin</span> <span class=o>!=</span> <span class=n>end</span><span class=p>)</span>
        <span class=o>*</span><span class=n>dest</span><span class=o>++</span> <span class=o>=</span> <span class=o>*</span><span class=n>begin</span><span class=o>++</span><span class=p>;</span>

    <span class=k>return</span> <span class=n>dest</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li> <li>"input-output iterator" - iterator support <code>*it, ++it, it++, (but not --it or it--), it == j, it != j, it-&gt;member</code> <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>For</span><span class=p>,</span> <span class=k>class</span> <span class=nc>X</span><span class=o>&gt;</span>
<span class=kt>void</span> <span class=n>replace</span><span class=p>(</span><span class=n>For</span> <span class=n>beg</span><span class=p>,</span> <span class=n>For</span> <span class=n>end</span><span class=p>,</span> <span class=k>const</span> <span class=n>X</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>,</span> <span class=k>const</span> <span class=n>X</span><span class=o>&amp;</span> <span class=n>y</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>beg</span> <span class=o>!=</span> <span class=n>end</span><span class=p>){</span>
        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>beg</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span>
            <span class=o>*</span><span class=n>beg</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>

            <span class=o>++</span><span class=n>beg</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li> <li>"reverse interator" - also support <code>--it</code> and <code>it--</code> <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>Bi</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>reverse</span><span class=p>(</span><span class=n>Bi</span> <span class=n>begin</span><span class=p>,</span> <span class=n>Bi</span> <span class=n>end</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>begin</span> <span class=o>!=</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
        <span class=o>--</span><span class=n>end</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>begin</span> <span class=o>!=</span> <span class=n>end</span><span class=p>)</span>
            <span class=n>swap</span><span class=p>(</span><span class=o>*</span><span class=n>begin</span><span class=o>++</span><span class=p>,</span> <span class=o>*</span><span class=n>end</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div></li> <li>Random access - support <code>p + n, p - n, n + p, p-q, p[n], (equivalent to *(p + n)) p &lt; q, p &gt; q, p &lt;= q, and p &gt;= q</code> <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>Ran</span><span class=p>,</span> <span class=k>class</span> <span class=nc>X</span><span class=o>&gt;</span>
<span class=kt>bool</span> <span class=n>binary_search</span><span class=p>(</span><span class=n>Ran</span> <span class=n>begin</span><span class=p>,</span> <span class=n>Ran</span> <span class=n>end</span><span class=p>,</span> <span class=k>const</span> <span class=n>X</span><span class=o>&amp;</span> <span class=n>x</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>begin</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// find the midpoint of the range</span>
        <span class=n>Ran</span> <span class=n>mid</span> <span class=o>=</span> <span class=n>begin</span> <span class=o>+</span> <span class=p>(</span><span class=n>end</span> <span class=o>-</span> <span class=n>begin</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
        <span class=c1>// see which part of the range contains x; keep looking only in that part</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>x</span> <span class=o>&lt;</span> <span class=o>*</span><span class=n>mid</span><span class=p>)</span>
            <span class=n>end</span> <span class=o>=</span> <span class=n>mid</span><span class=p>;</span>
        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=o>*</span><span class=n>mid</span> <span class=o>&lt;</span> <span class=n>x</span><span class=p>)</span>
            <span class=n>begin</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
            <span class=c1>// if we got here, then *mid == x so we&#39;re done</span>
        <span class=k>else</span>
            <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></li> <li>off-the-end values, it always ensure the range is [begin, end). The advantage? (see section 8.2.7)</li> <li>Input and output iterators<ol> <li>input iterator for <code>copy</code> <div class=codehilite><pre><span></span><code><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
<span class=c1>// read ints from the standard input and append them to v</span>
<span class=n>copy</span><span class=p>(</span><span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>cin</span><span class=p>),</span> <span class=n>istream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(),</span> <span class=n>back_inserter</span><span class=p>(</span><span class=n>v</span><span class=p>));</span>
</code></pre></div></li> <li>ouput iterator for <code>copy</code> <div class=codehilite><pre><span></span><code><span class=c1>// write the elements of v each separated from the other by a space</span>
<span class=n>copy</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>ostream_iterator</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>cout</span><span class=p>,</span> <span class=s>&quot; &quot;</span><span class=p>));</span>
</code></pre></div></li> </ol> </li> </ol> <h2 id=chapter-9>Chapter 9<a class=headerlink href=#chapter-9 title="Permanent link">&para;</a></h2> <ol> <li>Using the <code>::</code> before the function name of a non-member function called by a member function. <div class=codehilite><pre><span></span><code><span class=n>doubel</span> <span class=n>Student_info</span><span class=o>::</span><span class=n>grad</span><span class=p>()</span> <span class=k>const</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=o>::</span><span class=n>grade</span><span class=p>(</span><span class=n>midterm</span><span class=p>,</span> <span class=k>final</span><span class=p>,</span> <span class=n>homework</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></li> <li><code>const</code> for member function means this member function will not change the member variable. Only const member functions may be called for const objects.</li> <li>We cannot call non-const functions on const objects. such as <code>read</code> memeber on <code>const Student_info</code>.</li> <li>When we pass a non-const object to a function that take const reference. The function will treat the object as if it were const, and compiler will only permit it to call const memeber functions.</li> <li>When we pass a nonconst object to a function that takes a const reference, then the function treats that object as if it were const, and the compiler will permit it to call only const members of such objects.</li> <li>difference of <code>class</code> and <code>struct</code>: default protection. <code>class</code> --&gt; private between <code>{</code> and first label. </li> <li>explicitly define a accessor <code>read</code> function, <code>string name() const { return n; }</code> will return a copy of member variable n instead return a reference, because we don't want the user to modifiy it.</li> <li>The "Synthesized constructor" will initialized the data memebers to a value based on how the object is created. </li> <li>if the object is local variable, will be default-initialized (undefined).</li> <li>If the object is used to init a container element, the members will be value-initialized(zero).</li> <li>Initialization rules:</li> <li>If an object is of a class type that defines one or more constructors, then the appropriate constructor completely controls initialization of the objects of that class.</li> <li>If an object is of built-in type, then value-initializing it sets it to zero, and default-initializing it gives it an undefined value.</li> <li>Otherwise, the object can be only of a class type that does not define any constructors. In that case, value- or default-initializing the object value- or default-initializes each of its data members. This initialization process will be recursive if any of the data members is of a class type with its own constructor.</li> <li><strong>constructor initializers</strong> <code>Student_info::Student_info() : final(0), midterm(0){}</code></li> <li>when we create a object:<ol> <li>the implementation allocate memory for the new object.</li> <li>it initializes the object, as directed by the constructor's initializer list.</li> <li>it executes the constructor body.</li> </ol> </li> <li>The implementation initializes every data member of every object, regardless of whether the constructor initializer list mentions those members. The constructor body may change these initial values subsequently, but the initialization happens before the constructor body begins execution. It is usually better to give a member an initial value explicitly, rather than assigning to it in the body of the constructor. By initializing rather than assigning a value, we avoid doing the same work twice.</li> <li>Constructors with Arguments: <code>Student_info::Student_info(istream&amp; is) { read(is); }</code></li> </ol> <h2 id=chapter-10>Chapter 10<a class=headerlink href=#chapter-10 title="Permanent link">&para;</a></h2> <ol> <li>All you can do with a function is to take its address or call it. Any use of function that is not a call is assumed to be taking its address.</li> <li>function pointer declarition: <code>int (*fp)(int)</code> in which <code>fp</code> is a function pointer, if we have another function definition: <code>int next(int){ return n+1; }</code> we can use it like this <code>fp = &amp;next</code> or <code>fp = next</code>. With &amp; or without it is essentially same.</li> <li>define a function pointer point to a function: <code>vector&lt;string&gt;(*sp)(const string &amp;) = split;</code></li> <li>we can call the next function such as <code>i = (*fp)(i);</code> or <code>i = fp(i);</code> calling function pointer automatically calling the function itself.</li> <li>function with a return value as a function pointer, can use <code>typedef</code>. For example: <div class=codehilite><pre><span></span><code><span class=c1>//define analysis_fp as the name of the type of an appropriate pointer</span>
<span class=k>typedef</span> <span class=nf>double</span> <span class=p>(</span><span class=o>*</span><span class=n>analysis_fp</span><span class=p>)(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Student_info</span><span class=o>&gt;&amp;</span><span class=p>);</span>
<span class=c1>//get_analysis_ptr returns a pointer to an analysis function</span>
<span class=n>analysis_fp</span> <span class=nf>get_analysis_ptr</span><span class=p>();</span>
<span class=c1>//the alternative and most important trick that has been played in the S2E tcg components.</span>
<span class=n>doubel</span> <span class=p>(</span><span class=o>*</span><span class=n>get_analysis_ptr</span><span class=p>())(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Student_info</span><span class=o>&gt;&amp;</span><span class=p>);</span>
</code></pre></div></li> <li>function pointer as parameter to <code>find_if</code>, Notice the <code>Pred</code> can be any type as long as <code>f(*begin)</code> has meaningful value. <div class=codehilite><pre><span></span><code><span class=kt>bool</span> <span class=nf>is_negative</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
<span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>In</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Pred</span><span class=o>&gt;</span>
<span class=n>In</span> <span class=n>find_if</span><span class=p>(</span><span class=n>In</span> <span class=n>begin</span><span class=p>,</span> <span class=n>In</span> <span class=n>end</span><span class=p>,</span> <span class=n>Pred</span> <span class=n>f</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>begin</span> <span class=o>!=</span> <span class=n>end</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>f</span><span class=p>(</span><span class=o>*</span><span class=n>begin</span><span class=p>))</span>
        <span class=o>++</span><span class=n>begin</span><span class=p>;</span>

    <span class=k>return</span> <span class=n>begin</span><span class=p>;</span>
<span class=p>}</span>
<span class=c1>// call it</span>
<span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>i</span> <span class=o>=</span> <span class=n>find_if</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=n>is_negative</span><span class=p>);</span>
</code></pre></div></li> <li><code>&lt;cstddef&gt;</code> header: <code>size_t</code>: unsigned type large enough to hold the size of any object. <code>ptrdiff_t</code>: the type of <code>p - q</code>, p, q are both pointer.</li> <li>static means only initialize once, not everytime the function calle or the object is initialized.</li> <li>sizeof() operator reports the results in <strong>bytes</strong>.</li> <li>ifstream and ofstream object doesn't like string for file path. It almost always require the name of the file to be a pointer to the initial element of a null-terminated character array.</li> <li>simplicity. What if the string facilities doesn't exist.</li> <li>historical. fstream is earlier than string facilities in c++</li> <li>compatibility. easier to interface with OS file I/O, which typically use such pointers to communicate.</li> <li>using <code>c_str</code> member function for string literal. `ifstream infile(filepath.c_str());</li> <li>example that read every file supplied in the commandline. <div class=codehilite><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>**</span> <span class=n>argv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>fail_count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>argc</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
        <span class=n>ifstream</span> <span class=n>in</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=k>if</span><span class=p>(</span><span class=n>in</span><span class=p>){</span>
            <span class=n>string</span> <span class=n>s</span><span class=p>;</span>
            <span class=k>while</span><span class=p>(</span><span class=n>getline</span><span class=p>(</span><span class=n>in</span><span class=p>,</span> <span class=n>s</span><span class=p>))</span>
                <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=n>cerr</span> <span class=o>&lt;&lt;</span> <span class=s>&quot;cannot open file &quot;</span> <span class=o>&lt;&lt;</span> <span class=n>argv</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
            <span class=o>++</span><span class=n>fail_count</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>fail_count</span><span class=p>;</span> <span class=c1>// very neat trick played here.</span>
<span class=p>}</span>
</code></pre></div></li> <li>Three kinds of memory management</li> <li>automatica memory management (local variable)</li> <li>statically allocated memory (<code>static int x</code>)<ol> <li>it allocate once and only once before the function contain the statement is ever called.</li> <li>every call to pointer_to_static will return a pointer to the same object.</li> <li>the pointer will be valid as long as the program runs, and invalid afterward.</li> </ol> </li> <li>dynamic allocation</li> <li>Allocate object of type T. <code>new T(args)</code> i.e. <code>int* p = new int(32);</code> allocate a object <code>int</code> with initial value is 32.</li> </ol> <hr> <h2 id=chapter-11-implement-a-vector-class>Chapter 11 (Implement a vector class)<a class=headerlink href=#chapter-11-implement-a-vector-class title="Permanent link">&para;</a></h2> <ol> <li>template function V.S. template class <div class=codehilite><pre><span></span><code><span class=err>template &lt;typename T&gt;</span>
<span class=err>T Vec (T a) {</span>
<span class=err>    // function body</span>
<span class=err>}</span>
</code></pre></div> and <div class=codehilite><pre><span></span><code><span class=err>template &lt;class T&gt; class Vec {</span>
<span class=c>public:</span>
<span class=c>    // interface</span>
<span class=c>private:</span>
<span class=c>    // implementation</span>
<span class=err>}</span>
</code></pre></div></li> <li>What it does when use <code>new</code> to allocate memory. (i.e. <code>new T[n]</code>)<ol> <li>allocate memory</li> <li>initialize the element by running the default constructor.</li> <li>the class T should have a default constructor.</li> </ol> </li> <li>A template class type should have the control over how a object created, copied, assigned, or destroyed.</li> <li><code>explicit Vec(size_type n) { create(n); }</code> mean using the constructor should be explicitly declared, such as <code>Vec(5)</code>, not <code>vec = 5</code></li> <li>Type names for the members. Using typedef such as <code>typedef T* iterator</code>.</li> <li>Define a overloaded operator: like define a function, the type of the operator(uniary or binary) defines how many parameters the function will have.</li> <li>If the operator is a function that is not a member, then the function has as many arguments as the operator has operands. The first argument is bound to the left operand; the second is bound to the right operand.</li> <li>If the operator is defined as a member function, then its left operand is implicitly bound to the object on which the operator is invoked. Member operator functions, therefore, take one less argument than the operator indicates.</li> <li>Index operator MUST be a member function. <code>T&amp; operator[](size_type i) { return data[i]; }</code>, User might also want to only read the element through the index operator, so we can also define another overlaoded version <code>const T&amp; operator[](size_type i) const { return data[i]; }</code>. Notice the index operator will return a reference instead of a value.</li> <li>implicitly copying<ol> <li>passing by value in function parameter passing. <code>vector&lt;int&gt; i; double d; d = median(i);</code></li> <li>return value from a function. (<code>string line; vector&lt;string&gt; words = split(line);</code>)</li> </ol> </li> <li>explicitly copying<ol> <li>assignment: <code>vector&lt;Student_info&gt; vec = vs;</code></li> </ol> </li> <li><strong>Copy constructor: </strong> is a member function with the same name as the name of the class <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Vec</span><span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Vec</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>v</span><span class=p>);</span> <span class=p>{</span> <span class=n>create</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=p>}</span> <span class=c1>//copy constructor</span>
<span class=p>};</span>
</code></pre></div><ol> <li>using reference because we are defining what it means by copy, so we go deep to the granuality of call by reference to avoid copying.</li> <li>copying object shouldn't change the original vector, so we use const.</li> </ol> </li> <li>Because the copy of vector object is actually copy the pointer, the new copy of the original object contain the same data, point to the same data area. We should make sure they are not contain the same underlying storage when making copies of objects. We should do this: (note the <code>create</code> function hasn't been implemented yet) <div class=codehilite><pre><span></span><code><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=k>class</span> <span class=nc>Vec</span><span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Vec</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span> <span class=n>create</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>());</span> <span class=p>}</span> <span class=c1>//copy constructor made a copy.</span>
<span class=p>}</span>
</code></pre></div></li> <li><strong>assignment operator</strong>: it must be defined as a member function.(may have multiple overloaded versions.) Assignment differs from the copy constructor in that assignment always involves obliterating an existing value (the left-hand side) and replacing it with a new value (the right-hand side). <div class=codehilite><pre><span></span><code><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>Vec</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>Vec</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>//assignment operator</span>
<span class=p>};</span>

<span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
<span class=n>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&amp;</span> <span class=n>Vec</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Vec</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=o>&amp;</span><span class=n>rhs</span> <span class=o>!=</span> <span class=k>this</span><span class=p>){</span>
        <span class=n>uncreate</span><span class=p>();</span>
        <span class=n>create</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>rhs</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span> <span class=c1>//why we need &#39;*this&#39; here instead of &#39;this&#39;</span>
<span class=p>}</span>
</code></pre></div><ol> <li>return reference</li> <li>uncreate and create</li> <li>return variable scope</li> </ol> </li> <li>How to define a tempalte member function outside of the class?<ul> <li>When we should have the <code>T</code> in <code>Vec&lt;T&gt;&amp; Vec&lt;T&gt;::operator=(const Vec&amp; rhs)</code>?</li> </ul> </li> <li>the <code>oprator=</code> have two different meanings in C++<ol> <li>Initialization. Such as we do <code>vector&lt;int&gt; vec = v(10);</code> or <code>int a = 10;</code> we are invoking the copy constructor. Initialization involves creating a new object and giving it a value at the same time. Initialization happens:<ol> <li>In variable declarations (explicitly)</li> <li>For function parameters on entry to a function (implicitly)</li> <li>For the return value of a function on return from the function (implicitly)</li> <li>In constructor initializers (explicitly)</li> </ol> </li> <li>Assignment, we are calling <code>operator=</code>. Assignment (operator=) always obliterates a previous value; initialization never does so.</li> <li>examples: <div class=codehilite><pre><span></span><code>    <span class=n>string</span> <span class=n>url_ch</span> <span class=o>=</span> <span class=s>&quot;~;/?:@=&amp;$-_.+!*&#39;(),&quot;</span> <span class=c1>// initialization,(constructor + copy constructor)</span>
    <span class=n>string</span> <span class=n>spaces</span><span class=p>(</span><span class=n>url_ch</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=sc>&#39; &#39;</span><span class=p>)</span> <span class=p>;</span> <span class=c1>// initialization</span>
    <span class=n>string</span> <span class=n>y</span><span class=p>;</span> <span class=c1>// initialization</span>
    <span class=n>y</span> <span class=o>=</span> <span class=n>url_ch</span><span class=p>;</span> <span class=c1>// assignment, call the operator= and obliterate a previous value.</span>

    <span class=c1>//more complex ones</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>split</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// function declaration</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span> <span class=c1>// initialization</span>
    <span class=n>v</span> <span class=o>=</span> <span class=n>split</span><span class=p>(</span><span class=n>line</span><span class=p>);</span> <span class=c1>// on entry, initialization of split&#39;s parameter from line;</span>
                        <span class=c1>// on exit, both initialization of the return value</span>
                        <span class=c1>// and assignment to v</span>
</code></pre></div></li> </ol> </li> <li>The declaration of split above is interesting because it defines a return type that is a class type. Assigning a class type return value from a function is a two-step process: First, the copy constructor is run to copy the return value into a temporary at the call site. Then the assignment operator is run to assign the value of that temporary to the left-hand operand.</li> <li>Constructors always control initialization.</li> <li>The operator= member function always controls assignment.</li> <li>Defalut action regarding the copy constructor, assignment operator, and destructor:</li> <li>rule of three: copy constructor, destructor, and assignment operator. if you defind a class, you probably need the following for copy control and assignment operators. <div class=codehilite><pre><span></span><code><span class=n>T</span><span class=o>::</span><span class=n>T</span><span class=p>()</span> <span class=n>one</span> <span class=n>or</span> <span class=n>more</span> <span class=n>constructors</span><span class=p>,</span> <span class=n>perhaps</span> <span class=n>with</span> <span class=n>arguments</span>
<span class=n>T</span><span class=o>::~</span><span class=n>T</span><span class=p>()</span> <span class=n>the</span> <span class=n>destructor</span>
<span class=n>T</span><span class=o>::</span><span class=n>T</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>)</span> <span class=n>the</span> <span class=n>copy</span> <span class=n>constructor</span>
<span class=n>T</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>)</span> <span class=n>the</span> <span class=n>assignment</span> <span class=k>operator</span>
</code></pre></div></li> <li>the compiler will invoke them whenever an object of our type is created, copied, assigned, or destroyed. Remember that objects may be created, copied, or destroyed implicitly. Whether implicitly or explicitly, the compiler will invoke the appropriate operation.</li> <li>consideration in design a vector class:<ol> <li>constructor</li> <li>type definition</li> <li>index and size (overload operators)</li> <li>copy control</li> <li>destructor</li> </ol> </li> <li>Flexible Memory Management, those functions that used to implement the <code>create</code> and <code>uncreate</code> functions.<ol> <li><code>new</code> always initialized every object by using constructor <code>T::T()</code>. If we want to initialized by ourselves, we have to do it twice.</li> <li><code>allocator&lt;T&gt;</code> class in <code>&lt;memory&gt;</code> library. Members and non member function: <div class=codehilite><pre><span></span><code><span class=n>T</span><span class=o>*</span> <span class=nf>allocate</span><span class=p>(</span><span class=kt>size_t</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>deallocate</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>construct</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>;</span>
<span class=kt>void</span> <span class=nf>destroy</span><span class=p>(</span><span class=n>T</span><span class=o>*</span><span class=p>);</span>
<span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>Out</span><span class=p>,</span> <span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=n>uninitialized_fill</span><span class=p>(</span><span class=n>Out</span><span class=p>,</span> <span class=n>Out</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span><span class=p>);</span>
<span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>In</span><span class=p>,</span> <span class=k>class</span> <span class=nc>Out</span><span class=o>&gt;</span> <span class=n>Out</span> <span class=n>uninitialized_copy</span><span class=p>(</span><span class=n>In</span><span class=p>,</span> <span class=n>In</span><span class=p>,</span> <span class=n>Out</span><span class=p>);</span>
</code></pre></div></li> </ol> </li> </ol> <h2 id=chapter-12-making-class-objects-working-like-values>Chapter 12 (Making class objects working like values)<a class=headerlink href=#chapter-12-making-class-objects-working-like-values title="Permanent link">&para;</a></h2> <h2 id=chapter-13-inheritance>Chapter 13 (Inheritance)<a class=headerlink href=#chapter-13-inheritance title="Permanent link">&para;</a></h2> <ol> <li>the derived class will not inherit the following: constuctor, assignment operator, and destructor.</li> <li>Keyword <code>protected</code> allows the derived class to access the private member of the base.</li> <li>derived class is constructed by the following steps:<ol> <li>allocate memory for the entire object.(base member and derived class member.)</li> <li>call base constructor to initialize the base part.</li> <li>initialize the member of the derived class by initializer list.</li> <li>call constructor of the derived class. NOTE: However, it doesn't select which base constructor to run, we have to explicitly involke it.</li> </ol> </li> <li>"The derived-class constructor initializer names its base class followed by a (possibly empty) list of arguments. These arguments are the initial values to use in constructing the base- class part; they serve to select the base-class constructor to run in order to initialize the base."</li> <li>If we pass <code>Grad*</code> to function that take <code>Core*</code>, Compiler convert <code>grad*</code> to <code>Core*</code> and bind the parameter to a <code>Core*</code> type.</li> <li>Static binding V.S. Dynamic binding. "The phrase dynamic binding captures the notion that functions may be bound at run time, as opposed to static bindings that happen at compile time."</li> <li>Virtual Function: (mainly for pointer and references, not for explicit object, because the later is bind to the function in compile time.)<ol> <li>It come into being in the following accasion: <div class=codehilite><pre><span></span><code><span class=kt>bool</span> <span class=nf>compare_grade</span><span class=p>(</span><span class=k>const</span> <span class=n>Core</span><span class=o>&amp;</span> <span class=n>c1</span><span class=p>,</span> <span class=k>const</span> <span class=n>Core</span><span class=o>&amp;</span> <span class=n>c2</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=n>c1</span><span class=p>.</span><span class=n>grade</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>c2</span><span class=p>.</span><span class=n>grade</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div> which function to call, it has to be decide in run time. The reason is that the parameter type <code>const Core&amp;</code> can also accept a type <code>Grade*</code>.</li> <li>More examples. <div class=codehilite><pre><span></span><code><span class=n>Core</span> <span class=n>c</span><span class=p>;</span>
<span class=n>Grad</span> <span class=n>g</span><span class=p>;</span>
<span class=n>Core</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
<span class=n>Core</span><span class=o>&amp;</span> <span class=n>r</span> <span class=o>=</span> <span class=n>g</span><span class=p>;</span>
<span class=n>c</span><span class=p>.</span><span class=n>grade</span><span class=p>();</span>  <span class=c1>// statically bound to Core::grade()</span>
<span class=n>g</span><span class=p>.</span><span class=n>grade</span><span class=p>();</span>  <span class=c1>// statically bound to Core::grade()</span>
<span class=n>p</span><span class=o>-&gt;</span><span class=n>grade</span><span class=p>();</span> <span class=c1>// dynamically bound, depending on the type of the object to which p points</span>
<span class=n>r</span><span class=p>.</span><span class=n>grade</span><span class=p>();</span>  <span class=c1>// dynamically bound, depending on the type of the object to which p points</span>
</code></pre></div></li> </ol> </li> <li>if we defind the <code>bool compare_grade(const Core C1, const Core C2)</code>, if we pass <code>Grad</code> to it, it <strong>cut down</strong> to its core part. The two <code>grade()</code> would be identically from <code>Core</code>. If we define pointer parameters, the compiler will convert <code>Grad*</code> to a <code>Core*</code>, and would bind the pointer to the <code>Core</code> part of the <code>Grad</code> object.</li> <li>polymorphism: one type (base type) stand for many types (by reference and poitners). "C++ supports polymorphism through the dynamic-binding properties of virtual functions. When we call a virtual through a pointer or reference, we make a polymorphic call. The type of the reference (or pointer) is fixed, but the type of the object to which it refers (or points) can be the type of the reference (or pointer) or any type derived from it. Thus, we can potentially call one of many functions through a single type."</li> <li>virtual function must be defined, regardless of whether the program calles them.</li> <li>virtual destructor: usually in base not in derived class. it usually empty if not other special thing need todo.</li> <li>virtual properties are inherented, such as virtual function or virtual destructor, the keyword "virtual" only need to be defined in the base class, and no need to redeclared in derived class.</li> <li>virtual destructor: when you delete the heap memory using the command delete, the pointer operand for delete might be more than one class types. you have give the compiler right indication what object space to release, we use the virutal destructor to do this, for example: <div class=codehilite><pre><span></span><code><span class=k>class</span> <span class=nf>Core</span><span class=p>(){</span>
<span class=k>public</span><span class=o>:</span>
        <span class=n>virutal</span> <span class=o>~</span><span class=n>Core</span><span class=p>(){}</span><span class=c1>//empty destructor is enough</span>
<span class=p>}</span>
</code></pre></div> In this case the delete will automatically select the synthesized approperiate destructor for base class.</li> <li>A virtual destructor is needed any time it is possible that an object of derived type is destroyed through a pointer to base.</li> <li>A virtual destructor is inherited and we don't need to add the virtual destructor to the derived class such as <code>Grad</code>. </li> <li>Programming technique: handle class. hide the pointer manipulations and encapsulate the pointer to <code>Core</code>.</li> <li>static member function. Static member functions differ from ordinary member functions in that they do not operate on an object of the class type. Unlike other member functions, they are associated with the class, not with a particular object.</li> <li>How to implement copy constructor? give the handle class a virtual function <code>clone()</code> to implement the copy constructor. another wrapper!!! <div class=codehilite><pre><span></span><code><span class=k>class</span> <span class=nc>Core</span> <span class=p>{</span>
    <span class=k>friend</span> <span class=k>class</span> <span class=nc>Student_info</span><span class=p>;</span>
<span class=k>protected</span><span class=o>:</span>
    <span class=k>virtual</span> <span class=n>Core</span><span class=o>*</span> <span class=n>clone</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=k>new</span> <span class=n>Core</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>);}</span>
    <span class=c1>//as before.</span>
<span class=p>};</span>
</code></pre></div> Notice that the copy constructor didn't defined explicitly. It is synthesized by the implementation. (default copy constructor)</li> <li>Ordinarily, when a derived class redefines a function from the base class, it does so exactly: the parameter list and the return type are identical. However, if the base-class function returns a pointer (or reference) to a base class, then the derived-class function can return a pointer (or reference) to a corresponding derived class.</li> <li>"Finally, the objects that were allocated inside the read for the Student_info function will be automatically freed when we exit main. On exiting main, the vector will be destroyed. The destructor for vector will destroy each element in students, which will cause the destructor for Student_info to be run. When that destructor runs, it will delete each of the objects allocated in read."</li> <li> <p>look at the following piece of code: what will happen, if you mistake on the type of the class. <div class=codehilite><pre><span></span><code><span class=n>vector</span><span class=o>&lt;</span><span class=n>Core</span><span class=o>&gt;</span> <span class=n>students</span><span class=p>;</span>
<span class=n>Grad</span> <span class=nf>g</span><span class=p>(</span><span class=n>cin</span><span class=p>);</span>            <span class=c1>// read a Grad</span>
<span class=n>students</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>g</span><span class=p>);</span>  <span class=c1>// Store only the core part of the object.</span>
</code></pre></div> What will happen is that push_back will expect that it was given a Core object, and will construct a Core element, copying only the Core parts of the object, ignoring whatever is specific to the Grad class.</p> </li> <li> <p>We can control which function to call by specify the scope operator, such as when r is a reference to Grad, we can call the regrade function of Core. <div class=codehilite><pre><span></span><code><span class=err>r.Core::regrade(100);</span>
</code></pre></div></p> </li> <li>keep in mind that base function is always hiden if you call the derived class function member when the two are have same form (see 13.6.2 in page 347)</li> </ol> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid"> <a href=../../../courses/cs224n/lec-notes/ title="CS224N Lecture Notes" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel=next> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> Next </span> CS224N Lecture Notes </span> </div> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Rui Han </div> powered by <a href=https://www.mkdocs.org target=_blank rel=noopener>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs</a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/application.c33a9706.js></script> <script>app.initialize({version:"1.1",url:{base:"../../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>