<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://ruihan.org/leetcode/array/notes/ rel=canonical><link rel="shortcut icon" href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.0.2"><title>Array - RUIHAN.ORG</title><link rel=stylesheet href=../../../assets/stylesheets/main.38780c08.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f72e892.min.css><meta name=theme-color content=#000000><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=black data-md-color-accent=black> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#array class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=https://ruihan.org title=RUIHAN.ORG class="md-header-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> RUIHAN.ORG </span> <span class="md-header-nav__topic md-ellipsis"> Array </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class="md-tabs md-tabs--active" aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../books/ class=md-tabs__link> Books </a> </li> <li class=md-tabs__item> <a href=../../../courses/ class=md-tabs__link> Courses </a> </li> <li class=md-tabs__item> <a href=../../ class="md-tabs__link md-tabs__link--active"> Leetcode </a> </li> <li class=md-tabs__item> <a href=../../../research/ class=md-tabs__link> Research </a> </li> <li class=md-tabs__item> <a href=../../../seedlabs/ class=md-tabs__link> SEED Labs </a> </li> <li class=md-tabs__item> <a href=../../../system-design/ class=md-tabs__link> System Design </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=https://ruihan.org title=RUIHAN.ORG class="md-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> RUIHAN.ORG </label> <div class=md-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1> <label class=md-nav__link for=nav-1> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../books/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../books/accelerated-cpp/notes/ class=md-nav__link> Accelerated C++ </a> </li> <li class=md-nav__item> <a href=../../../books/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Datasets </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Courses <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Courses data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Courses </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../courses/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../courses/machine-learning-coursera/notes/ class=md-nav__link> Machine Learning (Coursera) </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/lec-notes/ class=md-nav__link> CS224N Lecture Notes </a> </li> <li class=md-nav__item> <a href=../../../courses/cs224n/write-up/ class=md-nav__link> CS224N Write-up </a> </li> <li class=md-nav__item> <a href=../../../courses/coursera-dl4-cnn/notes/ class=md-nav__link> Convolutional Neural Networks </a> </li> <li class=md-nav__item> <a href=../../../courses/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Data Sets </a> </li> <li class=md-nav__item> <a href=../../../courses/6.431-probability/notes/ class=md-nav__link> 6.431 Probability </a> </li> <li class=md-nav__item> <a href=../../../courses/learning-from-data/notes.md class=md-nav__link> Learning From Data </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-system-design/notes/ class=md-nav__link> Nine Chapter System Design </a> </li> <li class=md-nav__item> <a href=../../../courses/9chap-dynamic-prog/notes/ class=md-nav__link> Nine Chapter Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../courses/func-prog-in-scala/notes/ class=md-nav__link> Functional Programming Principles in Scala </a> </li> <li class=md-nav__item> <a href=../../../courses/applied-scrum-for-agile/notes/ class=md-nav__link> Applied Scrum for Agile Project Management </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3 checked> <label class=md-nav__link for=nav-3> Leetcode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Leetcode data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> Leetcode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> Index </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Array <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Array </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#category-1-removecontains-duplidate class=md-nav__link> Category 1 Remove/Contains Duplidate </a> <nav class=md-nav aria-label="Category 1 Remove/Contains Duplidate"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#contains-duplicate class=md-nav__link> Contains Duplicate </a> </li> <li class=md-nav__item> <a href=#contains-duplicate-ii class=md-nav__link> Contains Duplicate II </a> </li> <li class=md-nav__item> <a href=#contains-duplicate-iii class=md-nav__link> Contains Duplicate III </a> </li> <li class=md-nav__item> <a href=#find-the-duplicate-number class=md-nav__link> Find the Duplicate Number </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-array class=md-nav__link> Remove Duplicates from Sorted Array </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-array-ii class=md-nav__link> Remove Duplicates from Sorted Array II </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-list-ii class=md-nav__link> Remove Duplicates from Sorted List II </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-list class=md-nav__link> Remove Duplicates from Sorted List </a> </li> <li class=md-nav__item> <a href=#move-zeroes class=md-nav__link> Move Zeroes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-2-matrix-problems class=md-nav__link> Category 2 Matrix problems </a> <nav class=md-nav aria-label="Category 2 Matrix problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#spiral-matrix class=md-nav__link> Spiral Matrix </a> </li> <li class=md-nav__item> <a href=#spiral-matrix-ii class=md-nav__link> Spiral Matrix II </a> </li> <li class=md-nav__item> <a href=#search-a-2d-matrix class=md-nav__link> Search a 2D Matrix </a> </li> <li class=md-nav__item> <a href=#search-a-2d-matrix-ii class=md-nav__link> Search a 2D Matrix II </a> </li> <li class=md-nav__item> <a href=#rotate-image class=md-nav__link> Rotate Image </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-mutable class=md-nav__link> Range Sum Query 2D - Mutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-immutable class=md-nav__link> Range Sum Query 2D - Immutable </a> </li> <li class=md-nav__item> <a href=#maximal-square class=md-nav__link> Maximal Square </a> </li> <li class=md-nav__item> <a href=#maximal-rectangle class=md-nav__link> Maximal Rectangle </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-3-subarray-problems class=md-nav__link> Category 3 Subarray problems </a> <nav class=md-nav aria-label="Category 3 Subarray problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#type-of-subarray-problem class=md-nav__link> Type of subarray problem </a> </li> <li class=md-nav__item> <a href=#two-types-of-prefix-sum class=md-nav__link> Two types of prefix sum </a> </li> <li class=md-nav__item> <a href=#using-prefix-sum-with-map class=md-nav__link> Using prefix sum with map </a> </li> <li class=md-nav__item> <a href=#maximum-subarray class=md-nav__link> Maximum Subarray </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-ii class=md-nav__link> Maximum Subarray II* </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-iii class=md-nav__link> Maximum Subarray III* </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-difference class=md-nav__link> Maximum Subarray Difference* </a> </li> <li class=md-nav__item> <a href=#maximum-product-subarray class=md-nav__link> Maximum Product Subarray </a> </li> <li class=md-nav__item> <a href=#subarray-product-less-than-k class=md-nav__link> Subarray Product Less Than K </a> </li> <li class=md-nav__item> <a href=#subarray-sum class=md-nav__link> Subarray Sum* </a> </li> <li class=md-nav__item> <a href=#minimum-size-subarray-sum class=md-nav__link> Minimum Size Subarray Sum </a> </li> <li class=md-nav__item> <a href=#maximum-size-subarray-sum-equals-k class=md-nav__link> Maximum Size Subarray Sum Equals k </a> </li> <li class=md-nav__item> <a href=#subarray-sum-equals-k class=md-nav__link> Subarray Sum Equals K </a> </li> <li class=md-nav__item> <a href=#subarray-sums-divisible-by-k class=md-nav__link> Subarray Sums Divisible by K </a> </li> <li class=md-nav__item> <a href=#max-sum-of-subarry-no-larger-than-k class=md-nav__link> Max Sum of Subarry No Larger Than K* </a> </li> <li class=md-nav__item> <a href=#max-sum-of-rectangle-no-larger-than-k class=md-nav__link> Max Sum of Rectangle No Larger Than K </a> </li> <li class=md-nav__item> <a href=#maximum-sum-rectangular-submatrix-in-matrix class=md-nav__link> Maximum Sum Rectangular Submatrix in Matrix* </a> </li> <li class=md-nav__item> <a href=#subarray-sum-closest class=md-nav__link> Subarray Sum Closest* </a> </li> <li class=md-nav__item> <a href=#shortest-unsorted-continuous-subarray-count-inversions class=md-nav__link> Shortest Unsorted Continuous Subarray (Count inversions) </a> </li> <li class=md-nav__item> <a href=#count-inversion-course-assignment class=md-nav__link> Count Inversion (course assignment) </a> </li> <li class=md-nav__item> <a href=#count-of-smaller-numbers-after-self class=md-nav__link> Count of Smaller Numbers After Self </a> </li> <li class=md-nav__item> <a href=#continuous-subarray-sum class=md-nav__link> Continuous Subarray Sum </a> </li> <li class=md-nav__item> <a href=#contiguous-array class=md-nav__link> Contiguous Array </a> </li> <li class=md-nav__item> <a href=#split-array-with-equal-sum class=md-nav__link> Split Array with Equal Sum </a> </li> <li class=md-nav__item> <a href=#410-split-array-largest-sum class=md-nav__link> 410. Split Array Largest Sum </a> </li> <li class=md-nav__item> <a href=#copy-books class=md-nav__link> Copy Books* </a> </li> <li class=md-nav__item> <a href=#maximum-average-subarray-i class=md-nav__link> Maximum Average Subarray I </a> </li> <li class=md-nav__item> <a href=#maximum-average-subarray-ii class=md-nav__link> Maximum Average Subarray II </a> </li> <li class=md-nav__item> <a href=#range-sum-query-immutable class=md-nav__link> Range Sum Query - Immutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-mutable class=md-nav__link> Range Sum Query - Mutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-immutable_1 class=md-nav__link> Range Sum Query 2D - Immutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-mutable_1 class=md-nav__link> Range Sum Query 2D - Mutable </a> </li> <li class=md-nav__item> <a href=#maximum-sum-of-two-non-overlapping-subarrays class=md-nav__link> Maximum Sum of Two Non-Overlapping Subarrays </a> </li> <li class=md-nav__item> <a href=#maximum-sum-of-3-non-overlapping-subarrays class=md-nav__link> Maximum Sum of 3 Non-Overlapping Subarrays </a> </li> <li class=md-nav__item> <a href=#longest-substring-without-repeating-characters class=md-nav__link> Longest Substring Without Repeating Characters </a> </li> <li class=md-nav__item> <a href=#longest-substring-with-at-most-two-distinct-characters class=md-nav__link> Longest Substring with At Most Two Distinct Characters </a> </li> <li class=md-nav__item> <a href=#longest-substring-with-at-most-k-distinct-characters class=md-nav__link> Longest Substring with At Most K Distinct Characters </a> </li> <li class=md-nav__item> <a href=#subarrays-with-k-different-integers class=md-nav__link> Subarrays with K Different Integers </a> </li> <li class=md-nav__item> <a href=#number-of-substrings-containing-all-three-characters class=md-nav__link> Number of Substrings Containing All Three Characters </a> </li> <li class=md-nav__item> <a href=#count-number-of-nice-subarrays class=md-nav__link> Count Number of Nice Subarrays </a> </li> <li class=md-nav__item> <a href=#replace-the-substring-for-balanced-string class=md-nav__link> Replace the Substring for Balanced String </a> </li> <li class=md-nav__item> <a href=#binary-subarrays-with-sum class=md-nav__link> Binary Subarrays With Sum </a> </li> <li class=md-nav__item> <a href=#fruit-into-baskets class=md-nav__link> Fruit Into Baskets </a> </li> <li class=md-nav__item> <a href=#shortest-subarray-with-sum-at-least-k class=md-nav__link> Shortest Subarray with Sum at Least K </a> </li> <li class=md-nav__item> <a href=#minimum-size-subarray-sum_1 class=md-nav__link> Minimum Size Subarray Sum </a> </li> <li class=md-nav__item> <a href=#substring-with-concatenation-of-all-words class=md-nav__link> Substring with Concatenation of All Words </a> </li> <li class=md-nav__item> <a href=#max-consecutive-ones-ii class=md-nav__link> Max Consecutive Ones II </a> </li> <li class=md-nav__item> <a href=#max-consecutive-ones-iii class=md-nav__link> Max Consecutive Ones III </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-4-k-sum-problems class=md-nav__link> Category 4 K Sum problems </a> <nav class=md-nav aria-label="Category 4 K Sum problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#two-sum class=md-nav__link> Two Sum </a> </li> <li class=md-nav__item> <a href=#two-sum-ii-input-array-is-sorted class=md-nav__link> Two Sum II - Input array is sorted </a> </li> <li class=md-nav__item> <a href=#two-sum-iii-data-structure-design class=md-nav__link> Two Sum III - Data structure design </a> </li> <li class=md-nav__item> <a href=#two-sum-iv-input-is-a-bst class=md-nav__link> Two Sum IV - Input is a BST </a> </li> <li class=md-nav__item> <a href=#3sum class=md-nav__link> 3Sum </a> </li> <li class=md-nav__item> <a href=#3sum-closest class=md-nav__link> 3Sum Closest </a> </li> <li class=md-nav__item> <a href=#3sum-smaller class=md-nav__link> 3Sum Smaller </a> </li> <li class=md-nav__item> <a href=#4sum class=md-nav__link> 4Sum </a> </li> <li class=md-nav__item> <a href=#4sum-ii class=md-nav__link> 4Sum II </a> </li> <li class=md-nav__item> <a href=#k-sum class=md-nav__link> K Sum </a> </li> <li class=md-nav__item> <a href=#target-sum class=md-nav__link> Target Sum </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#cagegory-5-2d-arry-matrix-grid-problems class=md-nav__link> Cagegory 5 2D arry (matrix, grid) problems </a> <nav class=md-nav aria-label="Cagegory 5 2D arry (matrix, grid) problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#perfect-rectangle class=md-nav__link> Perfect Rectangle </a> </li> <li class=md-nav__item> <a href=#trapping-rain-water class=md-nav__link> Trapping Rain Water </a> </li> <li class=md-nav__item> <a href=#trapping-rain-water-ii class=md-nav__link> Trapping Rain Water II </a> </li> <li class=md-nav__item> <a href=#container-with-most-water class=md-nav__link> Container With Most Water </a> </li> <li class=md-nav__item> <a href=#largest-rectangle-in-histogram class=md-nav__link> Largest Rectangle in Histogram </a> </li> <li class=md-nav__item> <a href=#maximal-rectangle_1 class=md-nav__link> Maximal Rectangle </a> </li> <li class=md-nav__item> <a href=#maximal-square_1 class=md-nav__link> Maximal Square </a> </li> <li class=md-nav__item> <a href=#the-skyline-problem class=md-nav__link> The Skyline Problem </a> </li> <li class=md-nav__item> <a href=#smallest-rectangle-enclosing-black-pixels class=md-nav__link> Smallest Rectangle Enclosing Black Pixels </a> </li> <li class=md-nav__item> <a href=#rectangle-area class=md-nav__link> Rectangle Area </a> </li> <li class=md-nav__item> <a href=#max-sum-of-rectangle-no-larger-than-k_1 class=md-nav__link> Max Sum of Rectangle No Larger Than K </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-6-stock-buying-problems class=md-nav__link> Category 6 stock buying problems </a> <nav class=md-nav aria-label="Category 6 stock buying problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#121-best-time-to-buy-and-sell-stock class=md-nav__link> 121. Best Time to Buy and Sell Stock </a> </li> <li class=md-nav__item> <a href=#122-best-time-to-buy-and-sell-stock-ii class=md-nav__link> 122. Best Time to Buy and Sell Stock II </a> </li> <li class=md-nav__item> <a href=#123-best-time-to-buy-and-sell-stock-iii class=md-nav__link> 123. Best Time to Buy and Sell Stock III </a> </li> <li class=md-nav__item> <a href=#188-best-time-to-buy-and-sell-stock-iv class=md-nav__link> 188. Best Time to Buy and Sell Stock IV </a> </li> <li class=md-nav__item> <a href=#309-best-time-to-buy-and-sell-stock-with-cooldown class=md-nav__link> 309. Best Time to Buy and Sell Stock with Cooldown </a> </li> <li class=md-nav__item> <a href=#714-best-time-to-buy-and-sell-stock-with-transaction-fee class=md-nav__link> 714. Best Time to Buy and Sell Stock with Transaction Fee </a> </li> <li class=md-nav__item> <a href=#determine-the-buy-data-and-sell-data-of-maximum-profit-dd-139 class=md-nav__link> Determine the buy data and sell data of maximum profit (DD 139) </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../backtracking/notes/ class=md-nav__link> Backtracking </a> </li> <li class=md-nav__item> <a href=../../binary-search/notes/ class=md-nav__link> Binary Search </a> </li> <li class=md-nav__item> <a href=../../breadth-first-search/notes/ class=md-nav__link> Breadth-First Search (BFS) </a> </li> <li class=md-nav__item> <a href=../../depth-first-search/notes/ class=md-nav__link> Depth-First Search (DFS) </a> </li> <li class=md-nav__item> <a href=../../dynamic-programming/notes/ class=md-nav__link> Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../graph/notes/ class=md-nav__link> Graph </a> </li> <li class=md-nav__item> <a href=../../heap/notes/ class=md-nav__link> Heap </a> </li> <li class=md-nav__item> <a href=../../interval/notes/ class=md-nav__link> Interval </a> </li> <li class=md-nav__item> <a href=../../linked-list/notes/ class=md-nav__link> Linked List </a> </li> <li class=md-nav__item> <a href=../../math/notes/ class=md-nav__link> Math </a> </li> <li class=md-nav__item> <a href=../../stack/notes/ class=md-nav__link> Stack </a> </li> <li class=md-nav__item> <a href=../../string/notes/ class=md-nav__link> String </a> </li> <li class=md-nav__item> <a href=../../tree/notes/ class=md-nav__link> Tree </a> </li> <li class=md-nav__item> <a href=../../trie/notes/ class=md-nav__link> Trie </a> </li> <li class=md-nav__item> <a href=../../union-find/notes/ class=md-nav__link> Union Find </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Research <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Research data-md-level=1> <label class=md-nav__title for=nav-4> <span class="md-nav__icon md-icon"></span> Research </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../research/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../research/paper-reading/notes/ class=md-nav__link> Paper Reading </a> </li> <li class=md-nav__item> <a href=../../../research/coalition-game/notes/ class=md-nav__link> Coalition Game </a> </li> <li class=md-nav__item> <a href=../../../research/contextual-bandit/notes/ class=md-nav__link> Contextual Multi-Armed Bandit </a> </li> <li class=md-nav__item> <a href=../../../research/tfidf-score/notes/ class=md-nav__link> TF-IDF for Information Retrieval </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> SEED Labs <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SEED Labs" data-md-level=1> <label class=md-nav__title for=nav-5> <span class="md-nav__icon md-icon"></span> SEED Labs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../seedlabs/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/applied-crypto/notes/ class=md-nav__link> Applied Cryptograph Notes </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ class=md-nav__link> Public Key Cryptography and PKI </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-6 type=checkbox id=nav-6> <label class=md-nav__link for=nav-6> System Design <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="System Design" data-md-level=1> <label class=md-nav__title for=nav-6> <span class="md-nav__icon md-icon"></span> System Design </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../system-design/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../system-design/concepts/notes/ class=md-nav__link> Distributed System Concepts </a> </li> <li class=md-nav__item> <a href=../../../system-design/patterns/notes/ class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/tinyurl/notes/ class=md-nav__link> How to Design TinyUrl </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/twitter/notes/ class=md-nav__link> How to Design Twitter </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/ticketmaster/notes/ class=md-nav__link> How to Design Ticketmaster </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#category-1-removecontains-duplidate class=md-nav__link> Category 1 Remove/Contains Duplidate </a> <nav class=md-nav aria-label="Category 1 Remove/Contains Duplidate"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#contains-duplicate class=md-nav__link> Contains Duplicate </a> </li> <li class=md-nav__item> <a href=#contains-duplicate-ii class=md-nav__link> Contains Duplicate II </a> </li> <li class=md-nav__item> <a href=#contains-duplicate-iii class=md-nav__link> Contains Duplicate III </a> </li> <li class=md-nav__item> <a href=#find-the-duplicate-number class=md-nav__link> Find the Duplicate Number </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-array class=md-nav__link> Remove Duplicates from Sorted Array </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-array-ii class=md-nav__link> Remove Duplicates from Sorted Array II </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-list-ii class=md-nav__link> Remove Duplicates from Sorted List II </a> </li> <li class=md-nav__item> <a href=#remove-duplicates-from-sorted-list class=md-nav__link> Remove Duplicates from Sorted List </a> </li> <li class=md-nav__item> <a href=#move-zeroes class=md-nav__link> Move Zeroes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-2-matrix-problems class=md-nav__link> Category 2 Matrix problems </a> <nav class=md-nav aria-label="Category 2 Matrix problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#spiral-matrix class=md-nav__link> Spiral Matrix </a> </li> <li class=md-nav__item> <a href=#spiral-matrix-ii class=md-nav__link> Spiral Matrix II </a> </li> <li class=md-nav__item> <a href=#search-a-2d-matrix class=md-nav__link> Search a 2D Matrix </a> </li> <li class=md-nav__item> <a href=#search-a-2d-matrix-ii class=md-nav__link> Search a 2D Matrix II </a> </li> <li class=md-nav__item> <a href=#rotate-image class=md-nav__link> Rotate Image </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-mutable class=md-nav__link> Range Sum Query 2D - Mutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-immutable class=md-nav__link> Range Sum Query 2D - Immutable </a> </li> <li class=md-nav__item> <a href=#maximal-square class=md-nav__link> Maximal Square </a> </li> <li class=md-nav__item> <a href=#maximal-rectangle class=md-nav__link> Maximal Rectangle </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-3-subarray-problems class=md-nav__link> Category 3 Subarray problems </a> <nav class=md-nav aria-label="Category 3 Subarray problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#type-of-subarray-problem class=md-nav__link> Type of subarray problem </a> </li> <li class=md-nav__item> <a href=#two-types-of-prefix-sum class=md-nav__link> Two types of prefix sum </a> </li> <li class=md-nav__item> <a href=#using-prefix-sum-with-map class=md-nav__link> Using prefix sum with map </a> </li> <li class=md-nav__item> <a href=#maximum-subarray class=md-nav__link> Maximum Subarray </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-ii class=md-nav__link> Maximum Subarray II* </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-iii class=md-nav__link> Maximum Subarray III* </a> </li> <li class=md-nav__item> <a href=#maximum-subarray-difference class=md-nav__link> Maximum Subarray Difference* </a> </li> <li class=md-nav__item> <a href=#maximum-product-subarray class=md-nav__link> Maximum Product Subarray </a> </li> <li class=md-nav__item> <a href=#subarray-product-less-than-k class=md-nav__link> Subarray Product Less Than K </a> </li> <li class=md-nav__item> <a href=#subarray-sum class=md-nav__link> Subarray Sum* </a> </li> <li class=md-nav__item> <a href=#minimum-size-subarray-sum class=md-nav__link> Minimum Size Subarray Sum </a> </li> <li class=md-nav__item> <a href=#maximum-size-subarray-sum-equals-k class=md-nav__link> Maximum Size Subarray Sum Equals k </a> </li> <li class=md-nav__item> <a href=#subarray-sum-equals-k class=md-nav__link> Subarray Sum Equals K </a> </li> <li class=md-nav__item> <a href=#subarray-sums-divisible-by-k class=md-nav__link> Subarray Sums Divisible by K </a> </li> <li class=md-nav__item> <a href=#max-sum-of-subarry-no-larger-than-k class=md-nav__link> Max Sum of Subarry No Larger Than K* </a> </li> <li class=md-nav__item> <a href=#max-sum-of-rectangle-no-larger-than-k class=md-nav__link> Max Sum of Rectangle No Larger Than K </a> </li> <li class=md-nav__item> <a href=#maximum-sum-rectangular-submatrix-in-matrix class=md-nav__link> Maximum Sum Rectangular Submatrix in Matrix* </a> </li> <li class=md-nav__item> <a href=#subarray-sum-closest class=md-nav__link> Subarray Sum Closest* </a> </li> <li class=md-nav__item> <a href=#shortest-unsorted-continuous-subarray-count-inversions class=md-nav__link> Shortest Unsorted Continuous Subarray (Count inversions) </a> </li> <li class=md-nav__item> <a href=#count-inversion-course-assignment class=md-nav__link> Count Inversion (course assignment) </a> </li> <li class=md-nav__item> <a href=#count-of-smaller-numbers-after-self class=md-nav__link> Count of Smaller Numbers After Self </a> </li> <li class=md-nav__item> <a href=#continuous-subarray-sum class=md-nav__link> Continuous Subarray Sum </a> </li> <li class=md-nav__item> <a href=#contiguous-array class=md-nav__link> Contiguous Array </a> </li> <li class=md-nav__item> <a href=#split-array-with-equal-sum class=md-nav__link> Split Array with Equal Sum </a> </li> <li class=md-nav__item> <a href=#410-split-array-largest-sum class=md-nav__link> 410. Split Array Largest Sum </a> </li> <li class=md-nav__item> <a href=#copy-books class=md-nav__link> Copy Books* </a> </li> <li class=md-nav__item> <a href=#maximum-average-subarray-i class=md-nav__link> Maximum Average Subarray I </a> </li> <li class=md-nav__item> <a href=#maximum-average-subarray-ii class=md-nav__link> Maximum Average Subarray II </a> </li> <li class=md-nav__item> <a href=#range-sum-query-immutable class=md-nav__link> Range Sum Query - Immutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-mutable class=md-nav__link> Range Sum Query - Mutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-immutable_1 class=md-nav__link> Range Sum Query 2D - Immutable </a> </li> <li class=md-nav__item> <a href=#range-sum-query-2d-mutable_1 class=md-nav__link> Range Sum Query 2D - Mutable </a> </li> <li class=md-nav__item> <a href=#maximum-sum-of-two-non-overlapping-subarrays class=md-nav__link> Maximum Sum of Two Non-Overlapping Subarrays </a> </li> <li class=md-nav__item> <a href=#maximum-sum-of-3-non-overlapping-subarrays class=md-nav__link> Maximum Sum of 3 Non-Overlapping Subarrays </a> </li> <li class=md-nav__item> <a href=#longest-substring-without-repeating-characters class=md-nav__link> Longest Substring Without Repeating Characters </a> </li> <li class=md-nav__item> <a href=#longest-substring-with-at-most-two-distinct-characters class=md-nav__link> Longest Substring with At Most Two Distinct Characters </a> </li> <li class=md-nav__item> <a href=#longest-substring-with-at-most-k-distinct-characters class=md-nav__link> Longest Substring with At Most K Distinct Characters </a> </li> <li class=md-nav__item> <a href=#subarrays-with-k-different-integers class=md-nav__link> Subarrays with K Different Integers </a> </li> <li class=md-nav__item> <a href=#number-of-substrings-containing-all-three-characters class=md-nav__link> Number of Substrings Containing All Three Characters </a> </li> <li class=md-nav__item> <a href=#count-number-of-nice-subarrays class=md-nav__link> Count Number of Nice Subarrays </a> </li> <li class=md-nav__item> <a href=#replace-the-substring-for-balanced-string class=md-nav__link> Replace the Substring for Balanced String </a> </li> <li class=md-nav__item> <a href=#binary-subarrays-with-sum class=md-nav__link> Binary Subarrays With Sum </a> </li> <li class=md-nav__item> <a href=#fruit-into-baskets class=md-nav__link> Fruit Into Baskets </a> </li> <li class=md-nav__item> <a href=#shortest-subarray-with-sum-at-least-k class=md-nav__link> Shortest Subarray with Sum at Least K </a> </li> <li class=md-nav__item> <a href=#minimum-size-subarray-sum_1 class=md-nav__link> Minimum Size Subarray Sum </a> </li> <li class=md-nav__item> <a href=#substring-with-concatenation-of-all-words class=md-nav__link> Substring with Concatenation of All Words </a> </li> <li class=md-nav__item> <a href=#max-consecutive-ones-ii class=md-nav__link> Max Consecutive Ones II </a> </li> <li class=md-nav__item> <a href=#max-consecutive-ones-iii class=md-nav__link> Max Consecutive Ones III </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-4-k-sum-problems class=md-nav__link> Category 4 K Sum problems </a> <nav class=md-nav aria-label="Category 4 K Sum problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#two-sum class=md-nav__link> Two Sum </a> </li> <li class=md-nav__item> <a href=#two-sum-ii-input-array-is-sorted class=md-nav__link> Two Sum II - Input array is sorted </a> </li> <li class=md-nav__item> <a href=#two-sum-iii-data-structure-design class=md-nav__link> Two Sum III - Data structure design </a> </li> <li class=md-nav__item> <a href=#two-sum-iv-input-is-a-bst class=md-nav__link> Two Sum IV - Input is a BST </a> </li> <li class=md-nav__item> <a href=#3sum class=md-nav__link> 3Sum </a> </li> <li class=md-nav__item> <a href=#3sum-closest class=md-nav__link> 3Sum Closest </a> </li> <li class=md-nav__item> <a href=#3sum-smaller class=md-nav__link> 3Sum Smaller </a> </li> <li class=md-nav__item> <a href=#4sum class=md-nav__link> 4Sum </a> </li> <li class=md-nav__item> <a href=#4sum-ii class=md-nav__link> 4Sum II </a> </li> <li class=md-nav__item> <a href=#k-sum class=md-nav__link> K Sum </a> </li> <li class=md-nav__item> <a href=#target-sum class=md-nav__link> Target Sum </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#cagegory-5-2d-arry-matrix-grid-problems class=md-nav__link> Cagegory 5 2D arry (matrix, grid) problems </a> <nav class=md-nav aria-label="Cagegory 5 2D arry (matrix, grid) problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#perfect-rectangle class=md-nav__link> Perfect Rectangle </a> </li> <li class=md-nav__item> <a href=#trapping-rain-water class=md-nav__link> Trapping Rain Water </a> </li> <li class=md-nav__item> <a href=#trapping-rain-water-ii class=md-nav__link> Trapping Rain Water II </a> </li> <li class=md-nav__item> <a href=#container-with-most-water class=md-nav__link> Container With Most Water </a> </li> <li class=md-nav__item> <a href=#largest-rectangle-in-histogram class=md-nav__link> Largest Rectangle in Histogram </a> </li> <li class=md-nav__item> <a href=#maximal-rectangle_1 class=md-nav__link> Maximal Rectangle </a> </li> <li class=md-nav__item> <a href=#maximal-square_1 class=md-nav__link> Maximal Square </a> </li> <li class=md-nav__item> <a href=#the-skyline-problem class=md-nav__link> The Skyline Problem </a> </li> <li class=md-nav__item> <a href=#smallest-rectangle-enclosing-black-pixels class=md-nav__link> Smallest Rectangle Enclosing Black Pixels </a> </li> <li class=md-nav__item> <a href=#rectangle-area class=md-nav__link> Rectangle Area </a> </li> <li class=md-nav__item> <a href=#max-sum-of-rectangle-no-larger-than-k_1 class=md-nav__link> Max Sum of Rectangle No Larger Than K </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#category-6-stock-buying-problems class=md-nav__link> Category 6 stock buying problems </a> <nav class=md-nav aria-label="Category 6 stock buying problems"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#121-best-time-to-buy-and-sell-stock class=md-nav__link> 121. Best Time to Buy and Sell Stock </a> </li> <li class=md-nav__item> <a href=#122-best-time-to-buy-and-sell-stock-ii class=md-nav__link> 122. Best Time to Buy and Sell Stock II </a> </li> <li class=md-nav__item> <a href=#123-best-time-to-buy-and-sell-stock-iii class=md-nav__link> 123. Best Time to Buy and Sell Stock III </a> </li> <li class=md-nav__item> <a href=#188-best-time-to-buy-and-sell-stock-iv class=md-nav__link> 188. Best Time to Buy and Sell Stock IV </a> </li> <li class=md-nav__item> <a href=#309-best-time-to-buy-and-sell-stock-with-cooldown class=md-nav__link> 309. Best Time to Buy and Sell Stock with Cooldown </a> </li> <li class=md-nav__item> <a href=#714-best-time-to-buy-and-sell-stock-with-transaction-fee class=md-nav__link> 714. Best Time to Buy and Sell Stock with Transaction Fee </a> </li> <li class=md-nav__item> <a href=#determine-the-buy-data-and-sell-data-of-maximum-profit-dd-139 class=md-nav__link> Determine the buy data and sell data of maximum profit (DD 139) </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=array>Array<a class=headerlink href=#array title="Permanent link">&para;</a></h1> <h2 id=category-1-removecontains-duplidate>Category 1 Remove/Contains Duplidate<a class=headerlink href=#category-1-removecontains-duplidate title="Permanent link">&para;</a></h2> <h3 id=contains-duplicate>Contains Duplicate<a class=headerlink href=#contains-duplicate title="Permanent link">&para;</a></h3> <h3 id=contains-duplicate-ii>Contains Duplicate II<a class=headerlink href=#contains-duplicate-ii title="Permanent link">&para;</a></h3> <h3 id=contains-duplicate-iii>Contains Duplicate III<a class=headerlink href=#contains-duplicate-iii title="Permanent link">&para;</a></h3> <h3 id=find-the-duplicate-number>Find the Duplicate Number<a class=headerlink href=#find-the-duplicate-number title="Permanent link">&para;</a></h3> <h3 id=remove-duplicates-from-sorted-array>Remove Duplicates from Sorted Array<a class=headerlink href=#remove-duplicates-from-sorted-array title="Permanent link">&para;</a></h3> <h3 id=remove-duplicates-from-sorted-array-ii>Remove Duplicates from Sorted Array II<a class=headerlink href=#remove-duplicates-from-sorted-array-ii title="Permanent link">&para;</a></h3> <h3 id=remove-duplicates-from-sorted-list-ii>Remove Duplicates from Sorted List II<a class=headerlink href=#remove-duplicates-from-sorted-list-ii title="Permanent link">&para;</a></h3> <h3 id=remove-duplicates-from-sorted-list>Remove Duplicates from Sorted List<a class=headerlink href=#remove-duplicates-from-sorted-list title="Permanent link">&para;</a></h3> <h3 id=move-zeroes>Move Zeroes<a class=headerlink href=#move-zeroes title="Permanent link">&para;</a></h3> <h2 id=category-2-matrix-problems>Category 2 Matrix problems<a class=headerlink href=#category-2-matrix-problems title="Permanent link">&para;</a></h2> <h3 id=spiral-matrix>Spiral Matrix<a class=headerlink href=#spiral-matrix title="Permanent link">&para;</a></h3> <h3 id=spiral-matrix-ii>Spiral Matrix II<a class=headerlink href=#spiral-matrix-ii title="Permanent link">&para;</a></h3> <h3 id=search-a-2d-matrix>Search a 2D Matrix<a class=headerlink href=#search-a-2d-matrix title="Permanent link">&para;</a></h3> <h3 id=search-a-2d-matrix-ii>Search a 2D Matrix II<a class=headerlink href=#search-a-2d-matrix-ii title="Permanent link">&para;</a></h3> <h3 id=rotate-image>Rotate Image<a class=headerlink href=#rotate-image title="Permanent link">&para;</a></h3> <h3 id=range-sum-query-2d-mutable><a href=#range-sum-query-2d-mutable>Range Sum Query 2D - Mutable</a><a class=headerlink href=#range-sum-query-2d-mutable title="Permanent link">&para;</a></h3> <h3 id=range-sum-query-2d-immutable><a href=#range-sum-query-2d-immutable>Range Sum Query 2D - Immutable</a><a class=headerlink href=#range-sum-query-2d-immutable title="Permanent link">&para;</a></h3> <h3 id=maximal-square>Maximal Square<a class=headerlink href=#maximal-square title="Permanent link">&para;</a></h3> <h3 id=maximal-rectangle>Maximal Rectangle<a class=headerlink href=#maximal-rectangle title="Permanent link">&para;</a></h3> <h2 id=category-3-subarray-problems>Category 3 Subarray problems<a class=headerlink href=#category-3-subarray-problems title="Permanent link">&para;</a></h2> <h3 id=type-of-subarray-problem>Type of subarray problem<a class=headerlink href=#type-of-subarray-problem title="Permanent link">&para;</a></h3> <ul> <li>Find a subarray that fulfills a certain property, i.e maximum size subarray, <a href=#longest-substring-with-at-most-two-distinct-characters>Longest Substring with At Most Two Distinct Characters</a><ol> <li>Use map or two pointer to solve the problem.</li> </ol> </li> <li>Split into subarrays that fulfill certain properties, i.e. sum greater than k.</li> </ul> <div class="admonition note"> <p class=admonition-title>Fixed length subarray indexing</p> <p>To correctly index an array in solving subarray problems are critical. Here is some tips: 1. To iterate through a subarray of certain size, alwasy using the <strong>"one-of-the-end"</strong> pattern. Namely, the iteration index <code>i</code> point to the <strong>"one-off-the-end"</strong> of the subarray. The subarray of size K before the index is started at index <code>i - k</code>. 2. The above convention is especially useful in subarray problems given constrains, such as "the subarray size greater than <code>k</code>", "maximum sum of non-overlapping subarray", etc. 3. Example problems - <a href=#maximum-average-subarray-ii>Maximum Average Subarray II</a> - <a href=#maximum-sum-of-two-non-overlapping-subarrays>Maximum Sum of Two Non-Overlapping Subarrays</a></p> </div> <h3 id=two-types-of-prefix-sum>Two types of prefix sum<a class=headerlink href=#two-types-of-prefix-sum title="Permanent link">&para;</a></h3> <p>There are two ways to calculate the prefix sum array. Take which ever conveniece for your when solving a problem.</p> <p><strong>Option 1:</strong> <code>sums.resize(n, 0);</code></p> <div class=highlight><pre><span></span><code>nums: [1, 2, 3,  4,  5,  6,  7,  8,  9]
             i               j
sums: [1, 3, 6, 10, 15, 21, 28, 36, 45]
</code></pre></div> <p>In this case, each element <code>sums[i]</code> in sums represent the cumulative sum for indexes <code>[0, ..., i]</code>. In other words, <code>sum[i]</code> represent cumulative sum up to element <code>i</code> inclusive. When you want to get the range sum <code>rangeSum(i, j)</code>, you can get it in the following way:</p> <div class=highlight><pre><span></span><code><span class=n>rangeSum</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=n>sums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>-</span> <span class=n>sums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=c1>// i &gt; 0</span>
<span class=n>rangeSum</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=n>sums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>               <span class=c1>// i == 0</span>
</code></pre></div> <p>work with this option is a little complex, to get the <code>rangeSum(i, j)</code>:</p> <div class=highlight><pre><span></span><code><span class=n>rangeSum</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=n>sums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>-</span> <span class=n>sums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=c1>// i &gt;= 0</span>
</code></pre></div> <p><strong>Option 2:</strong> <code>sums.resize(n + 1, 0);</code></p> <p>In this case, each element <code>sums[i]</code> in sums represent the prefix sum of the first <code>i</code> elements in original array nums. When you want to get the range sum by <code>rangeSum(i, j)</code>, you can get it in the following way:</p> <div class=highlight><pre><span></span><code><span class=n>rangeSum</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=n>sums</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>sums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=c1>// i &gt;= 0</span>
</code></pre></div> <h3 id=using-prefix-sum-with-map>Using prefix sum with map<a class=headerlink href=#using-prefix-sum-with-map title="Permanent link">&para;</a></h3> <p>One of the core trick in solving the following subarray problems is to build a map from prefix sum to array index for efficient lookup. For example, problems with keywaords "maximum size equal to K", "differ by K", or "differ by multiple of k" are solved using this trick. There are two hints.</p> <div class="admonition hint"> <p class=admonition-title>Hint</p> <p>When a map is used, it need to be initialized using <code>&lt;0, -1&gt;</code>. It is useful for handling some of the corner cases such as <code>[-1, 1], -1</code> in the problem <a href=./#maximum-size-subarray-sum-equals-k>Maximum Size Subarray Sum Equals k</a>.</p> </div> <div class="admonition hint"> <p class=admonition-title>Hint</p> <p>It is usually easier to work with these problem when adding dummy element at the beginning of the array. For example: using <code>sums[i]</code> to represent the sum of first <code>i</code> element of array <code>nums</code>.</p> </div> <h3 id=maximum-subarray>Maximum Subarray<a class=headerlink href=#maximum-subarray title="Permanent link">&para;</a></h3> <p>Greedy solution</p> <p>```C++ tab="C++ Greedy solution" // why this greedy solution works? class Solution { public: int maxSubArray(vector<int>&amp; nums) { int n = nums.size(); int sum = 0; int max = 0; if (n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    max = nums[0];
    for (int i = 0; i &lt; n; i++) {
        sum += nums[i];
        max = sum &gt; max ? sum : max;
        sum = sum &gt; 0 ? sum : 0;
    }

    return max;
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Why can not compare to <code>f[i - 1])</code> to find the maximum. Because including the <code>f[i - 1]</code> will skip elements, the sum will not from a subarray, but sequence of numbers in the array. This is very similar to problems Longest Common Substring and Longest Common Subsequence </p> </div> <p><code>C++ tab="C++ DP" hl_lines="11" class Solution { public: int maxSubArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int res = INT_MIN; int f[n + 1] = {0}; // f[i] = maxSubArray of first i elements f[0] = 0; // initial value for (int i = 1; i &lt;= n; i++) { f[i] = max(f[i - 1] + nums[i - 1], nums[i - 1]); res = max(f[i], res); } return res; } }; // Notice this is a coordinate based DP problem, the meaning of the index i // in nums and f are different.</code></p> <p>Kadane's solution</p> <p>This is a DP solution, it reduced the f array to two variables. Making the problem <span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span> in space. <a href=http://blog.csdn.net/linhuanmars/article/details/21314059>Discuss about this solution</a>, where it make use of the idea of global maximum and local maximum.</p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>The idea of global maximum and local maximum is very usefull to solve DP problems. The local maximum is the maximum sum of a continuous subarray, the global maximum is keep the maximum of the local mmaximum.</p> </div> <p>```C++ tab="C++ Kadane's solution" hl_lines="9" class Solution { public: int maxSubArray(vector<int>&amp; nums) { int n = nums.size(); int res = INT_MIN; int curr = 0;</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; n; i++) {
        curr = max(curr + nums[i], nums[i]);
        res = max(curr, res);
    }

    return res;
}
</code></pre></div> <p>}; <code>Prefix sum solution The ideas is we have array sums, `sums[i] = A[0] +, ... + A[i]`, called prefix sum. With one for loop we can find the maxSum so far and the minSum before it. The difference is the possible results, we collect the maximum of those differences.</code>C++ tab="C++ prefix sum solution" public class Solution { public int maxSubArray(int[] A) { if (A == null || A.length == 0){ return 0; } int max = Integer.MIN_VALUE, sum = 0, minSum = 0; for (int i = 0; i &lt; A.length; i++) { sum += A[i]; max = Math.max(max, sum - minSum); minSum = Math.min(minSum, sum); } return max; } }; ```</p> <h3 id=maximum-subarray-ii>Maximum Subarray II*<a class=headerlink href=#maximum-subarray-ii title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code>Given an array of integers, find two non-overlapping subarrays which have the
largest sum. The number in each subarray should be contiguous. Return the largest
sum.

Notice
The subarray should contain at least one number

Example
For given [1, 3, -1, 2, -1, 2], the two subarrays are [1, 3] and [2, -1, 2] or
[1, 3, -1, 2] and [2], they both have the largest sum 7.
</code></pre></div> <p>Prefix sum solution</p> <p>```C++ tab="C++ Prefix sum solution" hl_lines="18 19 29 30" class Solution { public: /<em> * @param nums: A list of integers * @return: An integer denotes the sum of max two non-overlapping subarrays </em>/ int maxTwoSubArrays(vector<int> nums) { int n = nums.size(); int minSum = 0; int sums = 0; int maxSum = INT_MIN; int left [n] = {0}; int right [n] = {0};</p> <div class=highlight><pre><span></span><code>    /* calculate the prefix sum */
    for (int i = 0; i &lt; n; i++) {
        sums += nums[i];
        maxSum = max(maxSum, sums - minSum); // minSum is previous calculated
        minSum = min(minSum, sums);
        left[i] = maxSum;
    }

    /* calculate the postfix sum */
    minSum = 0;
    sums = 0;
    maxSum = INT_MIN;
    for (int i = n - 1; i &gt;= 0; i--) {
        sums += nums[i];
        maxSum = max(maxSum, sums - minSum);
        minSum = min(minSum, sums);
        right[i] = maxSum;
    }

    /* iterate the divider line, left[i] stored the maxSubArraySum
     * from nums[0] to nums[i], similar for right[i] */
    maxSum = INT_MIN;
    for (int i = 0; i &lt; n - 1; i++) {
        maxSum = max(maxSum, left[i] + right[i + 1]);
    }

    return maxSum;
}
</code></pre></div> <div class="admonition warning"> <p class=admonition-title>Warning</p> <p>Cannot swap the highlighted lines. Because the maximum sum is calculated from current sum minus the previous minSum. </p> </div> <h3 id=maximum-subarray-iii>Maximum Subarray III*<a class=headerlink href=#maximum-subarray-iii title="Permanent link">&para;</a></h3> <p><code>text Given an array of integers and a number k, find k non-overlapping subarrays which have the largest sum. The number in each subarray should be contiguous. Return the largest sum. Notice The subarray should contain at least one number Example Input: List = [-1,4,-2,3,-2,3] k = 2 Output: 8 Explanation: 4 + (3 + -2 + 3) = 8</code></p> <p>DP solution</p> <p>Use the idea of global maximum and local maximum from <a href=./#maximum-subarray>Maximum Subarray</a>. See <a href=https://zhengyang2015.gitbooks.io/lintcode/maximum_subarray_iii_43.html>this artical</a> for detailed explaination of the solution.</p> <p>```C++ tab="" class Solution { public: /*<em> * My initial try: O(n^2 k) * Partitioning DP: f[n][k], maximum K subarrays of first n elements. * Last partition: A[j] ,... A[n - 1] * f[i][k] = max_{0 &lt;= j &lt; i}(f[j][k - 1] + MS(A[j] ,... A[i - 1])) * f[0][0] = * * Solution 2, O(nk) * local[i][k]: Max k subarray sum from "first i elements" that include nums[i] * global[i][k]: Max k subarray sum from "first i elements" that may not include nums[i] * * 2 cases: nums[i - 1] is kth subarray, nums[i - 1] belongs to kth subarray * local[i][k] = max(global[i - 1][k - 1], local[i - 1][k]) + nums[i - 1] * * 2 cases: not include nums[i - 1], include nums[i - 1] * global[i][k] = max(global[i - 1][k], local[i][k]) </em>/ int maxSubArray(vector<int> nums, int k) { int n = nums.size();</p> <div class=highlight><pre><span></span><code>    int local[n + 1][k + 1] = {0};
    int global[n + 1][k + 1] = {0};

    for (int j = 1; j &lt;= k; j++) {
        // first j - 1 elements cannot form j groups, set to INT_MIN.
        local[j - 1][j] = INT_MIN;
        for (int i = j; i &lt;= n; i++) { // must: i &gt;= k.
            local[i][j] = max(global[i - 1][j - 1], local[i - 1][j]) + nums[i - 1];
            // the case when we divide k elements into k groups.
            if (i == j) {
                global[i][j] = local[i][j];
            } else {
                global[i][j] = max(global[i - 1][j], local[i][j]);
            }
        }
    }

    return global[n][k];
}
</code></pre></div> <p>}; ``` </p> <h3 id=maximum-subarray-difference>Maximum Subarray Difference*<a class=headerlink href=#maximum-subarray-difference title="Permanent link">&para;</a></h3> <p><code>text Given an array with integers. Find two non-overlapping subarrays A and B, which |SUM(A) - SUM(B)| is the largest. Return the largest difference. Notice The subarray should contain at least one number Example For [1, 2, -3, 1], return 6.</code></p> <p>Prefix sum solution</p> <p>We use the similar idea for problem <a href=./#maximum-subarray-ii>Maximum Subarray II</a>. We have to maintain four arrays. from forward maximum and minimum subarray sum and backward maximum and minimum subarray sum.</p> <p>```C++ tab="C++ Prefix sum solution" class Solution { public: /<em> * @param nums: A list of integers * @return: value of maximum difference between two subarrays </em>/ int maxDiffSubArrays(vector<int> nums) { int n = nums.size(); int minSum = 0; int sums = 0; int maxSum = INT_MIN;</p> <div class=highlight><pre><span></span><code>    int left_max[n] = {0};
    int left_min[n] = {0};
    int right_max[n] = {0};
    int right_min[n] = {0};

    for (int i = 0; i &lt; n; i++) {
        sums += nums[i];
        maxSum = max(maxSum, sums - minSum);
        minSum = min(minSum, sums);
        left_max[i] = maxSum;
        //left_min[i] = minSum;
    }

    minSum = INT_MAX;
    sums = 0;
    maxSum = 0;
    for (int i = 0; i &lt; n; i++) {
        sums += nums[i];
        minSum = min(minSum, sums - maxSum);
        maxSum = max(maxSum, sums);
        //left_max[i] = maxSum;
        left_min[i] = minSum;
    }

    minSum = 0;
    sums = 0;
    maxSum = INT_MIN;
    for (int i = n - 1; i &gt;= 0; i--) {
        sums += nums[i];
        maxSum = max(maxSum, sums - minSum);
        minSum = min(minSum, sums);
        right_max[i] = maxSum;
        //right_min[i] = minSum;
    }

    minSum = INT_MAX;
    sums = 0;
    maxSum = 0;
    for (int i = n - 1; i &gt;= 0; i--) {
        sums += nums[i];
        minSum = min(minSum, sums - maxSum);
        maxSum = max(maxSum, sums);
        //right_max[i] = maxSum;
        right_min[i] = minSum;
    }

    int diff = INT_MIN;
    for (int i = 0; i &lt; n - 1; i++) {
        diff = max(left_max[i] - right_min[i + 1], diff);
        diff = max(right_max[i + 1] - left_min[i], diff);
    }

    return diff;
}
</code></pre></div> <p>}; ``` </p> <h3 id=maximum-product-subarray>Maximum Product Subarray<a class=headerlink href=#maximum-product-subarray title="Permanent link">&para;</a></h3> <p>DP solution * It is similar to the problem <a href=./#maximum-subarray>Maximum Subarray</a>. Notice the negative number, min multiply a minus number could become the largest product. <code>C++ tab= class Solution { public: int maxProduct(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int max_pro[n] = {0}; int min_pro[n] = {0}; int result = nums[0]; max_pro[0] = nums[0]; min_pro[0] = nums[0]; for (int i = 1; i &lt; n; i++) { if (nums[i] &gt; 0) { max_pro[i] = max(max_pro[i - 1] * nums[i], nums[i]); min_pro[i] = min(min_pro[i - 1] * nums[i], nums[i]); } else { max_pro[i] = max(min_pro[i - 1] * nums[i], nums[i]); min_pro[i] = min(max_pro[i - 1] * nums[i], nums[i]); } result = max(result, max_pro[i]); } return result; } };</code></p> <p>Constant space solution</p> <p>Without need to check whether <code>nums[i]</code> is positive is negative, we can just find the maximum or minium of three cases.</p> <p>```C++ tab= class Solution { public: /<em> * @param nums: An array of integers * @return: An integer </em>/ int maxProduct(vector<int> nums) { int n = nums.size(); int res = nums[0]; int cur_max = nums[0]; int cur_min = nums[0];</p> <div class=highlight><pre><span></span><code>    for (int i = 1; i &lt; n; i++) {
        int tmp = cur_max;
        cur_max = max(max(cur_max * nums[i], nums[i]), cur_min * nums[i]);
        cur_min = min(min(cur_min * nums[i], nums[i]), tmp * nums[i]);
        res = max(res, cur_max);
    }

    return res;
}
</code></pre></div> <p>}; ``` </p> <h3 id=subarray-product-less-than-k>Subarray Product Less Than K<a class=headerlink href=#subarray-product-less-than-k title="Permanent link">&para;</a></h3> <h3 id=subarray-sum>Subarray Sum*<a class=headerlink href=#subarray-sum title="Permanent link">&para;</a></h3> <p><code>text Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number. Notice There is at least one subarray that it's sum equals to zero. Example Given [-3, 1, 2, -3, 4], return [0, 2] or [1, 3].</code></p> <p>Hash solution</p> <p>use a hash table to keep the prefix sum. Once we see another prefix sum that exists in the hash table, we discovered the subarray that sums to zero. However, pay attention to the indexing, because it requires to return the original array's index.</p> <p>```C++ tab= class Solution { public: /*<em> * @param nums: A list of integers * @return: A list of integers includes the index of the first number * and the index of the last number </em>/ vector<int> subarraySum(vector<int> nums){ int n = nums.size(); vector<int> res(2, 0); int sum = 0; unordered_map<int, int> map;</p> <div class=highlight><pre><span></span><code>    map[0] = -1; //important
    for (int i = 0; i &lt; n; i++) {
        sum += nums[i];
        if (map.count(sum) != 0) {
            res[0] = map[sum] + 1;
            res[1] = i;
            break;  
        }

        map[sum] = i;
    }

    return res;
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Pay attention to the initial value and initializethe <code>map[0] = -1</code>; This can be validated with an edge case. The time complexity is O(n) </p> </div> <p>Prefix sum solution Calculate the prefix sum first and then use the prefix sum to find the subarray. This solution is <span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span> <code>C++ class Solution { public: vector&lt;int&gt; subarraySum(vector&lt;int&gt; nums){ int n = nums.size(); vector&lt;int&gt; res(2, 0); vector&lt;int&gt; sum(n + 1, 0); sum[0] = 0; for (int i = 1; i &lt;= n; i++) { sum[i] = sum[i - 1] + nums[i - 1]; } for (int i = 0; i &lt; n; i++) { for (int j = i; j &lt;= n; j++) { if (j &gt; 1 &amp;&amp; sum[j] - sum[i] == 0) { res[0] = i; res[1] = j - 1; break; } } } return res; } };</code></p> <h3 id=minimum-size-subarray-sum>Minimum Size Subarray Sum<a class=headerlink href=#minimum-size-subarray-sum title="Permanent link">&para;</a></h3> <p>Accumulative sum solution</p> <p>Using accumulative sum and another moving pointer to check both the sum and the length of the subarray.</p> <p>```C++ tab="" class Solution { public: int minSubArrayLen(int s, vector<int>&amp; nums) { int n = nums.size(); if (n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    int sum = 0;
    int res = INT_MAX;
    int left = 0;

    for (int i = 0; i &lt; n; i++) {
        sum += nums[i];
        while (sum &gt;= s) {
            res = min(res, i - left + 1);
            sum -= nums[left++];
        }
    }

    return res != INT_MAX ? res : 0;
}
</code></pre></div> <p>}; ``` </p> <h3 id=maximum-size-subarray-sum-equals-k>Maximum Size Subarray Sum Equals k<a class=headerlink href=#maximum-size-subarray-sum-equals-k title="Permanent link">&para;</a></h3> <p>Similar to <a href=./continuous-subarray-sum>Continuous Subarray Sum</a> Hash solution Use a hash table to keep <code>&lt;sums, i&gt;</code> entries. Look up using <code>sum - k</code>. We only add to the hash table for the first time a value is appeared. It ensures the length of the found subarray is the largest. Notice you also have to initialize the hash with value <code>&lt;0, -1&gt;</code> to handle the edge case. <code>C++ tab= class Solution { public: int maxSubArrayLen(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if (n == 0) return 0; unordered_map&lt;int, int&gt; map; int sum = 0; int left = 0; int res = INT_MIN; map[0] = -1; for (int i = 0; i &lt; n; i++) { sum += nums[i]; if (map.count(sum - k) != 0) { left = map[sum - k] + 1; res = max(res, (i - left + 1)); } if (map.count(sum) == 0) { map[sum] = i; } } return res != INT_MIN ? res : 0; } }; /* test cases: 1. [-1, 1], -1 如果没有初始化hash，这个case就会错误 [-1, 0] sums 2. [-1], 0 3. [-1], -1 4. if return the result will be 1 if there is no res variable [1, 1, 0], 1 [1, 2, 2], 1 */</code></p> <h3 id=subarray-sum-equals-k>Subarray Sum Equals K<a class=headerlink href=#subarray-sum-equals-k title="Permanent link">&para;</a></h3> <p>Prefix sum solution</p> <p>Use prefix sum to find the subarray sum. Two pointer to check all the possible subarray sum.</p> <p>```C++ tab="C++ prefix sum solution" public class Solution { public int subarraySum(int[] nums, int k) { int count = 0; int[] sum = new int[nums.length + 1]; sum[0] = 0;</p> <div class=highlight><pre><span></span><code>    for (int i = 1; i &lt;= nums.length; i++)
        sum[i] = sum[i - 1] + nums[i - 1];

    for (int start = 0; start &lt; nums.length; start++) {
        for (int end = start + 1; end &lt;= nums.length; end++) {
            if (sum[end] - sum[start] == k)
                count++;
        }
    }
    return count;
}
</code></pre></div> <p>} <code>Hash solution Use a map to store the prefix sum and a counter. The idea is while calculating prefix sums, if we find an `sums - k` exist in the map, we found one of target subarray. The subtilty is for a particular prefix sum, there might be multiple earlier prefix sums differ from it by k. We should take this into account. Compare to the hash solution for problem [Subarray Sum](./subarray-sum).</code>text /<em> k = 2 i = 1, 2, 3 sum = 1, 2, 3 cnt = 0, 1, 2 key = 1, 2, 3 val = 1, 1, 1 the reason that the cnt += map[sum - k], not cnt += 1 is that the prefix sum "sum - k" has been shown up for total of map[sum - k] times. All those prefix sum could be result of distinct subarrays between current prefix sum and previous prefix sum "sum - k" </em>/ ```</p> <p>```C++ tab="" class Solution { public: int subarraySum(vector<int>&amp; nums, int k) { int n = nums.size(); // key=prefix sum, val=appearance unordered_map<int, int> map;</p> <div class=highlight><pre><span></span><code>    int cnt = 0;
    int sum = 0;

    map[0] = 1;
    for (int i = 0; i &lt; n; i++) {
        sum += nums[i];
        if (map.count(sum - k) != 0) {
            cnt += map[sum - k];
        }

        map[sum] += 1;
    }

    return cnt;
}
</code></pre></div> <div class="admonition warning"> <p class=admonition-title>Warning</p> <p>Notice you have to initialize the <code>map[0] = 1</code>; this is because for cases such as <code>[1, 1, 1]</code>, when <code>i = 1</code>, <code>sum = 2</code>, <code>[1,1]</code> should be counted as one subarray. Without setting <code>map[0] = 1</code> at first hand, it will give incorrect results. </p> </div> <h3 id=subarray-sums-divisible-by-k>Subarray Sums Divisible by K<a class=headerlink href=#subarray-sums-divisible-by-k title="Permanent link">&para;</a></h3> <ul> <li>preSum is the basis of continuous subarray profblem.</li> <li>One pass solution should explore a property of modulo <code>(preSum[j] - preSum[i]) % K == 0</code> indicate the when removing <code>K</code> from the larger value <code>preSum[j]</code> <code>n</code> times, we get the smaller value, then <code>preSum[j] % K == preSum[i] % K</code>. This property makes the one pass solution possible.</li> <li>Once the modulo property is found, we can use Hash map to assist our counting. The ideas is to keep counting the remainder, once we have seen the same remainder in the map, the new index and all the found indexes can be used to retrive one solution. The count keep in the map show how many of those can be. <code>C++ tab="One pass solution" class Solution { public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) { int n = A.size(); if (n == 0 || K == 0) { return 0; } int preSum = 0; unordered_map&lt;int, int&gt; mp; mp[0] = 1; int count = 0; for (int i = 0; i &lt; n; i++) { preSum += A[i]; int reminder = preSum % K; // deal with negative values if (reminder &lt; 0) reminder += K; if (mp.find(reminder) != mp.end()) { count += mp[reminder]; } mp[reminder] += 1; } return count; } };</code></li> </ul> <p>```C++ tab="Naive solution O(n^2)" class Solution { public: int subarraysDivByK(vector<int>&amp; A, int K) { int n = A.size(); if (n == 0 || K == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    vector&lt;long&gt; preSum(n + 1, 0);
    preSum[0] = 0;
    for (int i = 0; i &lt; n; i++) {
        preSum[i + 1] = preSum[i] + A[i];
    }
    int cnt = 0;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt;= n; j++) {
            if ((preSum[j] - preSum[i]) % K == 0) {
                cnt++;
            }
        }
    }

    return cnt;
}
</code></pre></div> <p>}; ``` </p> <h3 id=max-sum-of-subarry-no-larger-than-k>Max Sum of Subarry No Larger Than K*<a class=headerlink href=#max-sum-of-subarry-no-larger-than-k title="Permanent link">&para;</a></h3> <ol> <li>This problem in geeksforgeeks as "Maximum sum subarray having sum less than or equal to given sum".</li> <li>It has been discussed here.</li> <li>This problem is the basis to solve the problem 363. Max Sum of Rectangle No Larger Than K. Solution 1 using prefix sum and set </li> <li>calculate prefix and using a set to store individual prefix sum, (<code>vector</code> also works). In each iteration, we lookup the value <code>preSum - k</code> in the set.</li> <li>Notice we can use binary search to find the smallest element that <code>&gt;= preSum - k</code>. We can use <code>lower_bound</code> to achieve that. Notice if it is asking the sum less than k we have to use <code>upper_bound</code> <code>C++ tab= int maxSumSubarryNoLargerThanK (int A[], int n, int k) { set&lt;int&gt; preSumSet; preSumSet.insert(0); int res = 0, preSum = 0; for (int i = 0; i &lt; n; ++i) { preSum += A[i]; set&lt;int&gt;::iterator siter = preSumSet.lower_bound(preSum - k); if (siter != preSumSet.end() { res = max(res, preSum - *siter); } preSumSet.insert(preSum); } return res; }</code></li> </ol> <h3 id=max-sum-of-rectangle-no-larger-than-k>Max Sum of Rectangle No Larger Than K<a class=headerlink href=#max-sum-of-rectangle-no-larger-than-k title="Permanent link">&para;</a></h3> <p>Solution 1 iterate the wide of the matrix and using prefix sum and set <code>lower_bound</code>.</p> <ol> <li>To optimize it with the brute force solution, you will find this problem is a combination of the problem Maximum Sum Rectangular Submatrix in Matrix and problem Max Sum of Subarry No Larger Than K.</li> <li>From the problem Max Sum of Subarry No Larger Than K, we have to enumerate the width of the sub-matrix and sum up all row elements and get an array of length <code>m</code>, <code>m</code> is the number of rows of the matrix. Then apply the method.</li> </ol> <p>```C++ tab= class Solution { public: int maxSumSubmatrix(vector<vector\&lt;int>>&amp; matrix, int k) { if (matrix.empty()) return 0; int m = matrix.size(); int n = m ? matrix[0].size() : 0; int res = INT_MIN;</p> <div class=highlight><pre><span></span><code>    for (int l = 0; l &lt; n; ++l) {
        vector&lt;int&gt; sums(m, 0);
        for (int r = l; r &lt; n; ++r) {
            for (int i = 0; i &lt; m; ++i) {
                sums[i] += matrix[i][r];
            }

            set&lt;int&gt; preSumSet;
            preSumSet.insert(0);
            int preSum = 0, curMax = INT_MIN;
            for (int sum : sums) {
                preSum += sum;
                set&lt;int&gt;::iterator it = preSumSet.lower_bound(preSum - k);
                if (it != preSumSet.end()) {
                    curMax = max(curMax, preSum - *it);
                }
                preSumSet.insert(preSum);
            }

            res = max(res, curMax);
        }
    }

    return res;
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <ol> <li>The complexity is <span><span class=MathJax_Preview>n⋅n⋅(m+m\log m)=O(n⋅n⋅m\log m)</span><script type=math/tex>n⋅n⋅(m+m\log m)=O(n⋅n⋅m\log m)</script></span></li> <li>Notice the use of lower_bound, this function return iterator point to element greater than or equal to the value curSum - k, if use upper_bound, it will return iterator points to element greater than curSum - k, which would miss the equal to K case. </li> </ol> </div> <p>Solution 2 using merge sort 1. The idea is similar that solution 1. Instead of calculate <code>preSum</code> on the fly, we finish calculation and pass it to a <code>mergeSort</code> routine. 2. The use <code>mergeSort</code> here is to find the <code>A[j] - A[i] &lt;= k</code> efficiently, <code>O(nlogn)</code>. 3. The complexity is n⋅n⋅(m+m⋅\log m)=O(n⋅n⋅m⋅\log m) <code>C++ tab= class Solution { public: int maxSumSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { int m = matrix.size(); int n = m ? matrix[0].size() : 0; int res = INT_MIN; vector&lt;long long&gt; sums(m + 1, 0); for (int l = 0; l &lt; n; ++l) { vector&lt;long long&gt;sumInRow(m, 0); for (int r = l; r &lt; n; ++r) { for (int i = 0; i &lt; m; ++i) { sumInRow[i] += matrix[i][r]; sums[i + 1] = sums[i] + sumInRow[i]; } res = max(res, mergeSort(sums, 0, m + 1, k)); if (res == k) return k; } } return res; } int mergeSort(vector&lt;long long&gt;&amp; sums, int start, int end, int k) { if (end == start + 1) return INT_MIN; int mid = start + (end - start) / 2; int res = mergeSort(sums, start, mid, k); if (res == k) return k; res = max(res, mergeSort(sums, mid, end, k)); if (res == k) return k; long long cache[end - start]; int j = mid, c = 0, t = mid; for (int i = start; i &lt; mid; ++i) { /* search first time sums[j] - sums[i] &gt; k */ while (j &lt; end &amp;&amp; sums[j] - sums[i] &lt;= k) ++j; /* sums[j - 1] - sums[i] &lt;= k, make sure j - 1 is in right side */ if (j - 1 &gt;= mid) { res = max(res, (int)(sums[j - 1] - sums[i])); if (res == k) return k; } /* parallel merge */ while (t &lt; end &amp;&amp; sums[t] &lt; sums[i]) { cache[c++] = sums[t++]; } cache[c++] = sums[i]; } /* parallel merge */ for (int i = start; i &lt; t; ++i) { sums[i] = cache[i - start]; } return res; } };</code></p> <h3 id=maximum-sum-rectangular-submatrix-in-matrix>Maximum Sum Rectangular Submatrix in Matrix*<a class=headerlink href=#maximum-sum-rectangular-submatrix-in-matrix title="Permanent link">&para;</a></h3> <h3 id=subarray-sum-closest>Subarray Sum Closest*<a class=headerlink href=#subarray-sum-closest title="Permanent link">&para;</a></h3> <h3 id=shortest-unsorted-continuous-subarray-count-inversions>Shortest Unsorted Continuous Subarray (Count inversions)<a class=headerlink href=#shortest-unsorted-continuous-subarray-count-inversions title="Permanent link">&para;</a></h3> <p>Solution 1 using merge sort</p> <ol> <li>This problem is the basic of using merge sort to solve lots of hard problems.</li> </ol> <p>```C++ tab= long long merge_and_count(int A[], int start, int end) { if (end - start &lt;= 1) return 0;</p> <div class=highlight><pre><span></span><code>long long count = 0;
int mid = start + (end - start) / 2;
count = merge_and_count(A, start, mid)
        + merge_and_count(A, mid, end);

int j = mid;
int cache[end - start];
for (int i = start, k = 0; i &lt; mid; i++) {
    while (j &lt; end &amp;&amp; A[i] &gt; A[j]) {
        cache[k++] = A[j++];
        count += mid - i;
    }

    cache[k++] = A[i];
}
// copy cache[0, j - start) to A[start, j)
// if j &lt; end, then A[j, end) in final place.
for (int i = start; i &lt; j; i++) {
    A[i] = cache[i - start];
}

return count;
</code></pre></div> <p>} ``` </p> <h3 id=count-inversion-course-assignment>Count Inversion (course assignment)<a class=headerlink href=#count-inversion-course-assignment title="Permanent link">&para;</a></h3> <p>Solution 1 using merge sort 1. This problem is the basic of using merge sort to solve lots of hard problems. <code>C++ tab= long long merge_and_count(int A[], int start, int end) { if (end - start &lt;= 1) return 0; long long count = 0; int mid = start + (end - start) / 2; count = merge_and_count(A, start, mid) + merge_and_count(A, mid, end); int j = mid; int cache[end - start]; for (int i = start, k = 0; i &lt; mid; i++) { while (j &lt; end &amp;&amp; A[i] &gt; A[j]) { cache[k++] = A[j++]; count += mid - i; } cache[k++] = A[i]; } // copy cache[0, j - start) to A[start, j) // if j &lt; end, then A[j, end) in final place. for (int i = start; i &lt; j; i++) { A[i] = cache[i - start]; } return count; }</code></p> <h3 id=count-of-smaller-numbers-after-self>Count of Smaller Numbers After Self<a class=headerlink href=#count-of-smaller-numbers-after-self title="Permanent link">&para;</a></h3> <p>Solution 1 Merge sort</p> <ol> <li>One important point to remember is you have to create pairs out of the array element and its index, because during merge sort, when we count each value, we don't know where to put those count values in the result vector.</li> <li>The second merge solutions run much faster than the first one.</li> </ol> <p>```C++ tab="C++ Merge sort" class Solution { public: vector<int> countSmaller(vector<int>&amp; nums) { int n = nums.size(); vector<int> res(n, 0); vector<pair\&lt;int, int> > vp;</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; n; i++) {
        vp.emplace_back(nums[i], i);
    }

    merge_sort_count(vp, 0, n, res);

    return res;
}
</code></pre></div> <p>private: void merge_sort_count(vector<pair\&lt;int, int> >&amp; nums, int start, int end, vector<int>&amp; res) { if (end - start &lt;= 1) return;</p> <div class=highlight><pre><span></span><code>    int mid = start + (end - start) / 2;

    merge_sort_count(nums, start, mid, res);
    merge_sort_count(nums, mid, end, res);

    vector&lt;pair&lt;int, int&gt; &gt; cache(end - start, pair&lt;int, int&gt;(0, 0));

    int j = mid, k = 0, t = mid;
    for (int i = start; i &lt; mid; i++) {
        j = mid;
        while (j &lt; end &amp;&amp; nums[i].first &gt; nums[j].first) { // found smaller elements
            res[nums[i].second]++;
            j++;
        }

        while (t &lt; end &amp;&amp; nums[i].first &gt; nums[t].first) {
            cache[k++] = nums[t++];
        }

        cache[k++] = nums[i];
    }

    for (int i = start; i &lt; j; i++) {
        nums[i] = cache[i - start];
    }

    return;
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ more efficient Merge sort" class Solution { public: vector<int> countSmaller(vector<int>&amp; nums) { int n = nums.size(); vector<int> res(n, 0); vector<pair\&lt;int, int> > vp; for (int i = 0; i &lt; n; i++) { vp.emplace_back(nums[i], i); } mergeSort(vp, 0, n, res); return res; } void mergeSort(vector<pair\&lt;int, int>>&amp; x, int start, int end, vector<int>&amp; res) { if (end - start &lt;= 1) return; int mid = start + (end - start) / 2; mergeSort(x, start, mid, res); mergeSort(x, mid, end, res); vector<pair\&lt;int, int> > cache(end - start, pair<int, int>(0, 0)); int i = start, j = mid, k = 0; while(i &lt; mid &amp;&amp; j &lt; end) { if (x[i].first &lt;= x[j].first) { cache[k++] = x[i]; res[x[i].second] += j - mid; ++i; } else { cache[k++] = x[j++]; } } while(i &lt; mid) { cache[k++] = x[i]; res[x[i].second] += end - mid; ++i; } while(j &lt; end) cache[k++] = x[j++]; for(i = start, k = 0; i &lt; end; ++i, ++k) { x[i] = cache[k]; } } }; ```</p> <p>```C++ tab="C++ BST" class Solution { public: class TreeNode { public: int val, smallerCnt; TreeNode<em> left, </em>right; TreeNode(int v, int s) : left(NULL), right(NULL), val(v), smallerCnt(s){} }; vector<int> countSmaller(vector<int>&amp; nums) { int n = nums.size(); if(n == 0) return {}; vector<int> res(n, 0); TreeNode* root = NULL;</p> <div class=highlight><pre><span></span><code>    for(int i = n - 1; i &gt;= 0; --i)
        root = insert(root, nums[i], i, 0, res);

    return res;
}
</code></pre></div> <p>private: TreeNode<em> insert( TreeNode</em> node, int val, int idx, int preSum, vector<int>&amp; res) { if(node == NULL) { node = new TreeNode(val, 0); res[idx] = preSum; } else if(node-&gt;val &gt; val) { node-&gt;smallerCnt++; node-&gt;left = insert(node-&gt;left, val, idx, preSum, res); } else { node-&gt;right = insert(node-&gt;right, val, idx, preSum + node-&gt;smallerCnt + ((node-&gt;val &lt; val)? 1: 0), res); }</p> <div class=highlight><pre><span></span><code>    return node;
}
</code></pre></div> <p>}; ``` </p> <h3 id=continuous-subarray-sum>Continuous Subarray Sum<a class=headerlink href=#continuous-subarray-sum title="Permanent link">&para;</a></h3> <p>Hash solution Once see a multiple of K, you should consider the modulor operation <code>%</code> The values put into to the hash only for the first time, this is similar to the case in the problem Maximum Size Subarray Sum Equals k. <code>C++ tab="C++ Hash soution" hl_lines="11" class Solution { public: bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); if (n == 0) return false; unordered_map&lt;int, int&gt; map; int sum = 0; map[0] = -1; // test case [0, 0], 0 for (int i = 0; i &lt; n; i++) { sum += nums[i]; if (k != 0) sum = sum % k; if (map.count(sum) != 0) { if (i - map[sum] &gt; 1) { return true; } } else { map[sum] = i; } } return false; } };</code></p> <h3 id=contiguous-array>Contiguous Array<a class=headerlink href=#contiguous-array title="Permanent link">&para;</a></h3> <p>Similar problems:</p> <ul> <li><a href=./#continuous-subarray-sum>Continuous Subarray Sum</a></li> <li><a href=./#maximum-size-subarray-sum-equals-k>Maximum Size Subarray Sum Equals k</a></li> </ul> <p>Hash solution</p> <p>This problem is very similar to the problem <a href=./#continuous-subarray-sum>Continuous Subarray Sum</a>. However, there is a trick to calculate the cummulative sum, treat <code>0</code> as <code>-1</code>.</p> <p>```C++ tab= class Solution { public: int findMaxLength(vector<int>&amp; nums) { int n = nums.size(); int res = 0; int cnt = 0; unordered_map<int, int> map;</p> <div class=highlight><pre><span></span><code>    map[0] = -1; // test case: [0, 1]
    for (int i = 0; i &lt; n; i++) {
        cnt += nums[i] == 0 ? -1 : 1;
        if (map.count(cnt) != 0) {
            res = max(res, i - map[cnt]);
        } else {
            map[cnt] = i;
        }
    }

    return res;
}
</code></pre></div> <p>}; ``` </p> <h3 id=split-array-with-equal-sum>Split Array with Equal Sum<a class=headerlink href=#split-array-with-equal-sum title="Permanent link">&para;</a></h3> <p>Cummulative sum soluiton Because of the symetric property of the head subarray and trailing subarray, we can calculate cumulative sum from both direction. This can help to fix the index <code>i</code> and <code>k</code>. we can enumerate the index <code>j</code> in between. <code>C++ tab="C++ cummulateive sum solution" class Solution { public: bool splitArray(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int sum1[n] = {0}; int sum2[n] = {0}; sum1[0] = nums[0]; for (int i = 1; i &lt; n; i++) { sum1[i] = sum1[i - 1] + nums[i]; } sum2[n - 1] = nums[n - 1]; for (int i = n - 2; i &gt;= 0; i--) { sum2[i] = sum2[i + 1] + nums[i]; } // notice the index bounds for (int i = 1; i &lt; n - 5; i++) { for (int k = n - 2; k &gt; i + 3; k--) { if (sum1[i] - nums[i] == sum2[k] - nums[k]) { for (int j = i + 2; j &lt; k - 1; j++) { int sumij = sum1[j] - nums[j] - sum1[i]; int sumjk = sum2[j] - nums[j] - sum2[k]; if (sumij == sumjk) { return true; } } } } } return false; } };</code></p> <h3 id=410-split-array-largest-sum>410. Split Array Largest Sum<a class=headerlink href=#410-split-array-largest-sum title="Permanent link">&para;</a></h3> <p>Similar problems:</p> <ul> <li><a href=./#copy-books>Copy Books</a>.</li> </ul> <p>DP solution</p> <ul> <li>Notice the edge case: <code>[1, INT_MAX]</code>, use <code>double</code> can avoid integer overflow.</li> </ul> <p>Binary Search solution</p> <ul> <li>This is a greedy search solution that use binary search to accelerate the search speed</li> <li>The goal is to "minimize the largest sub-array sum". It is different from <a href=./#divide-chocolate>Divide Chocolate</a>, which is maximize the smallest sum.</li> <li>The bisection condition is not <code>A[m] &lt; target</code> any more. It is a function to check whether the constrain can meet given a guesss value <code>mid</code>.</li> </ul> <p>```C++ tab="C++ DP" /*<em> * equivalent to the lintcode copy books problem * * last step: mth subarray A[j], ..., A[i - 1]. * State: f[m][n]: minmax sum of m subarrays that include n elements * Equation: f[m][n] = min_{0&lt;=j&lt;n}(max(f[m - 1][j], sum(A[j], ..., A[n - 1]))) * Init: f[0][n] = INT_MAX; * f[0][0] = 0; * NB: notice a special case: [1, 2147483247], 2 * the sum will overflow in the state update, You use a double type<br> </em>/ class Solution { public: int splitArray(vector<int>&amp; nums, int m) { int n = nums.size();</p> <div class=highlight><pre><span></span><code>    double f[m + 1][n + 1];
    f[0][0] = 0;
    for (int i = 1; i &lt;= n; i++) {
        f[0][i] = INT_MAX;
    }

    double sum = 0;
    for (int k = 1; k &lt;= m; k++) {
        f[k][0] = 0;
        for (int i = 1; i &lt;= n; i++) {
            sum = 0;
            f[k][i] = INT_MAX;
            for (int j = i; j &gt;= 0; j--) {//j = i, mean sum = 0.
                f[k][i] = min(f[k][i], max(f[k - 1][j], sum));
                if (j &gt; 0) {
                    sum += nums[j - 1];
                }
            }
        }
    }

    return f[m][n];
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ binary search" class Solution { public: int splitArray(vector<int>&amp; nums, int m) { int total = 0; int mx = 0; for (int num: nums) { total += num; mx = max(mx, num); } int l = mx, r = total; while (l &lt; r) { int mid = l + (r - l) / 2; if (!canCut(nums, mid, m - 1)) { l = mid + 1; } else { r = mid; } } return l; } // whether m cuts are possible, notice the greedy property of this check // you should notice that if not possible, it is because mid is too small, // not because it is too large. bool canCut(vector<int>&amp; nums, int mid, int m) { int sum = 0; for (int num: nums) { if (num &gt; mid) return false; else if (sum + num &lt;= mid) sum += num; else { // cut is ok so far m--; if (m &lt; 0) return false; // more element after all cuts. sum = num; // init the next group sum } } return true; } }; ```</p> <h3 id=copy-books>Copy Books*<a class=headerlink href=#copy-books title="Permanent link">&para;</a></h3> <p>DP solution</p> <p>There are <code>i</code> books, consider the last copier, he can copy <code>A[j], ..., A[i-1]</code>. The first <code>k-1</code> copier copy <code>A[0], ..., A[j - 1]</code>.</p> <ul> <li>Define state: <code>f[k][i]</code>, meaning the k-th copier copy <code>i</code> books.</li> <li>State transition equation: <span><span class=MathJax_Preview>f[k][i] = \min_{0 \le j \le i} \max(f[k - 1][j], A[j] + ... + A[i - 1])</span><script type=math/tex>f[k][i] = \min_{0 \le j \le i} \max(f[k - 1][j], A[j] + ... + A[i - 1])</script></span></li> </ul> <p>```C++ tab="C++ DP solution" hl_lines="34 35 36 37 38 39" class Solution { public: /*<em> * last step: last copier copy A[j], ... A[i-1] * first k-1 copier --&gt; A[0], ... A[j - 1]. * f[k][i]: k copier copy i books. * f[k][i] = \min_{0 \le j \le i} \max(f[k - 1][j], A[j] + ... + A[i - 1]) </em>/ int copyBooks(vector<int> &amp;pages, int K) { // write your code here int n = pages.size(); if (n == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    if (K &gt; n) {
        K = n;
    }

    int f[K + 1][n + 1];

    /* init */
    f[0][0] = 0;
    for (int j = 1; j &lt;= n; j++) {
        f[0][j] = INT_MAX;
    }

    int sum = 0;
    for (int k = 1; k &lt;= K; k++) {
        f[k][0] = 0;
        for (int i = 1; i &lt;= n; i++) {
            sum = 0;
            f[k][i] = INT_MAX;
            for (int j = i; j &gt;= 0; j--) {
                f[k][i] = min(f[k][i], max(f[k - 1][j], sum));
                if (j &gt; 0) {
                    sum += pages[j - 1];
                }
            }
        }
    }

    return f[K][n];
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <p>We have to enumerate the index <code>j</code>, the highlighted code used a clever technique to optimize this task. It enumerate <code>j</code> backwards. While this seems impossible at the first glance, how can you calculate the states from right to left in DP? Notice the index <code>j</code> is in the upper row (row <code>k-1</code>). Once we are in the <code>k</code>-th row, the values in the <code>k-1</code>-th row are all given. </p> </div> <h3 id=maximum-average-subarray-i>Maximum Average Subarray I<a class=headerlink href=#maximum-average-subarray-i title="Permanent link">&para;</a></h3> <p>Prefix sum solution <code>C++ class Solution { public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); double sums[n] = {0}; double max_avg = INT_MIN; sums[0] = nums[0]; for (int i = 1; i &lt; n; i++) { sums[i] = sums[i - 1] + nums[i]; } for (int i = k - 1; i &lt; n; i++) { double avg = (sums[i] - sums[i - k + 1] + nums[i - k + 1]) / k; max_avg = max(max_avg, avg); } return max_avg; } };</code></p> <h3 id=maximum-average-subarray-ii>Maximum Average Subarray II<a class=headerlink href=#maximum-average-subarray-ii title="Permanent link">&para;</a></h3> <p>Prefix sum solution</p> <p>This is still a brute force solution.</p> <ul> <li>time complexity: <span><span class=MathJax_Preview>O(n^2)</span><script type=math/tex>O(n^2)</script></span></li> <li>space complexity: <span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span></li> </ul> <p>```C++ tab="C++ prefix sum solution" class Solution { public: double findMaxAverage(vector<int>&amp; nums, int k) { int n = nums.size(); vector<int> sums = nums;</p> <div class=highlight><pre><span></span><code>    for (int i = 1; i &lt; n; ++i) {
        sums[i] = sums[i - 1] + nums[i];
    }

    double res = (double) sums[k - 1] / k;
    for (int i = k; i &lt; n; ++i) {
        double t = sums[i];
        if (t &gt; res * (i + 1)) res = t / (i + 1);
        for (int j = 0; j &lt; i - k + 1; ++j) {
            t = sums[i] - sums[j];
            if (t &gt; res * (i - j)) res = t / (i - j);
        }
    }

    return res;
}
</code></pre></div> <p>}; <code>Space optimized solution * We could avoid using the prefix sum array and only use two variables to record the prefix sum at any particular instance. One for record prefix sum of exact `k` elements. Another for the inner loop to check whether removing an element from the beginning will make a new maximum value or not.</code>C++ tab="C++ space optimized" class Solution { public: double findMaxAverage(vector<int>&amp; nums, int k) { int n = nums.size(); /<em> range is half open </em>/ double sumsAll = accumulate(nums.begin(), nums.begin() + k, 0); double sums = sumsAll, res = sumsAll / k; for (int i = k; i &lt; n; ++i) { sumsAll += nums[i]; sums = sumsAll; if (sums &gt; res * (i + 1)) res = sums / (i + 1); for (int j = 0; j &lt; i - k + 1; ++j) { sums -= nums[j]; if (sums &gt; res * (i - j)) res = sums / (i - j); } } return res; } }; ```</p> <p>Binary search solution</p> <p>The key question to answer in order to solve this problem using binary search is that what condition we should use to serve the similar effect of cutting the input space in half in the original binary search. The answer is we can test whether it is possible to have an average value of subarray whose length is greater than or equal to k in the upper half.</p> <p>```C++ tab="C++ binary search soluiton" class Solution { public: double findMaxAverage(vector<int>&amp; nums, int k) { int n = nums.size(); double upper = INT_MIN, lower = INT_MAX;</p> <div class=highlight><pre><span></span><code>    for (auto num : nums) {
        upper = max(upper, (double)num);
        lower = min(lower, (double)num);
    }

    while (lower + 0.00001 &lt; upper) {
        double mid = lower + (upper - lower) / 2;
        if (isLarger(nums, mid, k)) { // is average value &gt;= mid?
            lower = mid;
        } else {
            upper = mid;
        }
    }

    return lower;
}

/* return true if a greater average value is possible */
bool isLarger(vector&lt;int&gt;&amp; nums, double mid, int k) {
    int n = nums.size();
    double sums = 0, prev = 0, prev_min = 0;
    for (int i = 0; i &lt; k; i++) {
        sums += nums[i] - mid;
    }

    if (sums &gt;= 0) {
        return true;
    }
    /*
     * we keep looking for whether a subarray sum of length &gt;= k in array
     * &quot;sums&quot; is possible to be greater than zero. If such a subarray exist,
     * it means that the target average value is greater than the &quot;mid&quot;
     * value. We look at the front part of sums that at least k element
     * apart from i. If we can find the minimum of the sums[0, 1, ..., i - k]
     * and check if sums[i] - min(sum[0, 1, ..., i - k]) &gt;= 0. If this is the
     * case, it indicate there exist a subarray of length &gt;= k with sum
     * greater than 0 in sums, we can return ture, otherwise, false.
     */
    for (int i = k; i &lt; n; i++) {
        sums += nums[i] - mid;
        prev += nums[i - k] - mid;
        prev_min = min(prev_min, prev);
        if (sums &gt;= prev_min)
            return true;
    }

    return false;
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Notice the initial value of prev_min is set to 0 not INT_MAX; Try to understand why set the initial value of prev_min to INT_MAX cannot pass the test case: <code>[8,9,3,1,8,3,0,6,9,2]</code>, 8. </p> </div> <p>Deque solution <code>C++ tab="C++ deque solution" class Solution { public: double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) { int n = nums.size(); vector&lt;double&gt; sums(n, 0); deque&lt;int&gt; q; sums[0] = nums[0]; for (int i = 1; i &lt; n; ++i) sums[i] = sums[i - 1] + nums[i]; double res = sums[n - 1] / n; for (int j = k - 1; j &lt; n; ++j) { while(q.size() &gt;= 2 &amp;&amp; density(sums, q[q.size() - 2], q.back() - 1) &gt;= density(sums, q.back(), j - k)) { q.pop_back(); } q.push_back(j - k + 1); while(q.size() &gt;= 2 &amp;&amp; density(sums, q[0], j) &lt;= density(sums, q[1], j)) { q.pop_front(); } res = max(res, density(sums, q.front(), j)); } return res; } private: double density(vector&lt;double&gt;&amp; sums, int l, int r) { if (l == 0) return sums[r] / (r + 1); return (sums[r] - sums[l - 1]) / (r - l + 1); } };</code></p> <h3 id=range-sum-query-immutable>Range Sum Query - Immutable<a class=headerlink href=#range-sum-query-immutable title="Permanent link">&para;</a></h3> <p>Prefix sum solution</p> <p>Use prefix sum to record the accumulative sum of the array in the constructor. The algorithm is <span><span class=MathJax_Preview>O(n)</span><script type=math/tex>O(n)</script></span> in space and <span><span class=MathJax_Preview>O(1)</span><script type=math/tex>O(1)</script></span> in time.</p> <p>```C++ tab= class NumArray { private: vector<int> sums; int n; public: NumArray(vector<int> nums) { n = nums.size(); sums.resize(n + 1, 0);</p> <div class=highlight><pre><span></span><code>    sums[0] = 0;
    for (int i = 1; i &lt;= n; ++i) {
        sums[i] = sums[i - 1] + nums[i - 1];
    }
}

int sumRange(int i, int j) {
    return sums[j + 1] - sums[i];
}
</code></pre></div> <p>}; /*<em> * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * int param_1 = obj.sumRange(i,j); </em>/ ``` </p> <h3 id=range-sum-query-mutable>Range Sum Query - Mutable<a class=headerlink href=#range-sum-query-mutable title="Permanent link">&para;</a></h3> <p>Segment tree solution Using segment tree, the solution is given at <a href=https://leetcode.com/problems/range-sum-query-mutable/solution/ >Leetcode Solution</a>. <code>C++ tab="C++ segment tree" class NumArray { private: vector&lt;int&gt; tree; int n; public: NumArray(vector&lt;int&gt; nums) { n = nums.size(); tree.resize(2 * n, 0); for (int i = n, j = 0; i &lt; 2 * n; ++i, ++j) { tree[i] = nums[j]; } for (int i = n - 1; i &gt; 0; --i) { tree[i] = tree[2 * i] + tree[2 * i + 1]; } } void update(int i, int val) { int pos = n + i; int left = 0; int right = 0; tree[pos] = val; while (pos &gt; 0) { left = pos; right = pos; if (pos % 2 == 0) { right = pos + 1; } if (pos % 2 == 1) { left = pos - 1; } tree[pos / 2] = tree[left] + tree[right]; pos /= 2; } } int sumRange(int i, int j) { int left = i + n; int right = j + n; int sum = 0; while (left &lt;= right) { if (left % 2 == 1) { sum += tree[left]; left++; } if (right % 2 == 0) { sum += tree[right]; right--; } left /= 2; right /= 2; } return sum; } }; /** * Your NumArray object will be instantiated and called as such: * NumArray obj = new NumArray(nums); * obj.update(i,val); * int param_2 = obj.sumRange(i,j); */</code></p> <p>Binary Indexed Tree solution I</p> <p>Using Binary indexed tree, we are able to solve it optimally in <span><span class=MathJax_Preview>O(\log n)</span><script type=math/tex>O(\log n)</script></span> . The solution originally from <a href=https://leetcode.com/problems/range-sum-query-mutable/discuss/75753/java-using-binary-indexed-tree-with-clear-explanation>here</a></p> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>NumArray</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>;</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>BIT</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>NumArray</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>arr</span> <span class=o>=</span> <span class=n>nums</span><span class=p>;</span>
        <span class=n>n</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=n>BIT</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>init</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>init</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
        <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>BIT</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>val</span><span class=p>;</span> <span class=c1>// BIT[i]  = nums[0, i - 1];</span>
            <span class=n>i</span> <span class=o>+=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=kt>void</span> <span class=n>update</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>diff</span> <span class=o>=</span> <span class=n>val</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
        <span class=n>init</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>diff</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>sumRange</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nf>getSum</span><span class=p>(</span><span class=n>j</span><span class=p>)</span> <span class=o>-</span> <span class=n>getSum</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>getSum</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>sum</span> <span class=o>+=</span> <span class=n>BIT</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=n>i</span> <span class=o>-=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>

<span class=cm>/**</span>
<span class=cm> * Your NumArray object will be instantiated and called as such:</span>
<span class=cm> * NumArray obj = new NumArray(nums);</span>
<span class=cm> * obj.update(i,val);</span>
<span class=cm> * int param_2 = obj.sumRange(i,j);</span>
<span class=cm> */</span>
</code></pre></div> <p>Binary Indexed Tree solution II</p> <p>Similar to the above solution, We have combined the <code>init</code> and <code>update</code>. To make it consistant with the solution with problem <a href=#range-sum-query-2d-mutable>Range Sum Query 2D - Mutable</a></p> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>NumArray</span> <span class=p>{</span>
<span class=k>private</span><span class=o>:</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>arr</span><span class=p>;</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>BIT</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>NumArray</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>n</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=n>BIT</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
        <span class=n>arr</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>update</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=cm>/* We can combine the init and update like this */</span>
    <span class=kt>void</span> <span class=n>update</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>val</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>diff</span> <span class=o>=</span> <span class=n>val</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span> <span class=c1>// here we initialize arr[i]</span>

        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
        <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>BIT</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>diff</span><span class=p>;</span> <span class=c1>// BIT[i]  = nums[0, i - 1];</span>
            <span class=n>i</span> <span class=o>+=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>sumRange</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nf>getSum</span><span class=p>(</span><span class=n>j</span><span class=p>)</span> <span class=o>-</span> <span class=n>getSum</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kt>int</span> <span class=n>getSum</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>sum</span> <span class=o>+=</span> <span class=n>BIT</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=n>i</span> <span class=o>-=</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=p>(</span><span class=o>-</span><span class=n>i</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>

<span class=cm>/**</span>
<span class=cm> * Your NumArray object will be instantiated and called as such:</span>
<span class=cm> * NumArray obj = new NumArray(nums);</span>
<span class=cm> * obj.update(i,val);</span>
<span class=cm> * int param_2 = obj.sumRange(i,j);</span>
<span class=cm> */</span>
</code></pre></div> <h3 id=range-sum-query-2d-immutable_1>Range Sum Query 2D - Immutable<a class=headerlink href=#range-sum-query-2d-immutable_1 title="Permanent link">&para;</a></h3> <p>Prefix sum solution</p> <p>Extended from the 1d array, we can use the prefix sum of the 2d matrix. we use extra space to store the accumulative sum of the submatrix with upper left coordinate <code>(0, 0)</code> and lower right coordinate <code>(i, j)</code>.</p> <p>```C++ tab="C++ prefix sum solution" class NumMatrix { private: vector<vector\&lt;int> > dp; public: NumMatrix(vector<vector\&lt;int>> matrix) { int m = matrix.size(); if (m == 0) return;</p> <div class=highlight><pre><span></span><code>    int n = matrix[0].size();

    //dp = vector&lt;vector&lt;int&gt; (m + 1, vector&lt;int&gt;(n + 1, 0));
    dp.resize(m + 1, vector&lt;int&gt;(n + 1, 0));

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j] + matrix[i][j] - dp[i][j];
        }
    }
}

int sumRegion(int row1, int col1, int row2, int col2) {
    return dp[row2 + 1][col2 + 1] - dp[row2 + 1][col1] - dp[row1][col2 + 1] + dp[row1][col1];
}
</code></pre></div> <p>};</p> <p>/*<em> * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * int param_1 = obj.sumRegion(row1,col1,row2,col2); </em>/ <div class=highlight><pre><span></span><code>!!! note
    This version create the `m + 1` by `n + 1` dp array to record the prefix sum.
    The code is clean and elegant.

Alternative prefix sum solution

The idea is the same, in the following solution, we have a `m` by `n` 2d array
to record the accumulative sum. See how complex the code is.

```C++ tab=&quot;C++ prefix sum solution&quot;
class NumMatrix {
private:
    vector&lt;vector&lt;int&gt;&gt; dp;
    int m;
    int n;
public:
    NumMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) {
        m = matrix.size();
        if (m == 0)
            return;
        n = matrix[0].size();
        dp.resize(m, vector&lt;int&gt;(n, 0));

        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                dp[i][j] = matrix[i][j];
                if (i &gt; 0) {
                    dp[i][j] += dp[i - 1][j];
                }

                if (j &gt; 0) {
                    dp[i][j] += dp[i][j - 1];
                }

                if (i &gt; 0 &amp;&amp; j &gt; 0) {
                    dp[i][j] -= dp[i - 1][j - 1];
                }
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        int res = 0;
        res = dp[row2][col2];

        if (row1 &gt; 0) {
            res -= dp[row1 - 1][col2];
        }

        if (col1 &gt; 0) {
            res -= dp[row2][col1 - 1];
        }

        if (row1 &gt; 0 &amp;&amp; col1 &gt; 0 ) {
            res += dp[row1 - 1][col1 - 1];
        }

        return res;
    }
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
</code></pre></div></p> <div class="admonition note"> <p class=admonition-title>Note</p> <p>This version is a little complex. However, the way it was written reflects a very important practice when operating on a 2d array, that is: to check the validation of the array.</p> </div> <h3 id=range-sum-query-2d-mutable_1>Range Sum Query 2D - Mutable<a class=headerlink href=#range-sum-query-2d-mutable_1 title="Permanent link">&para;</a></h3> <p>Binary Indexed Tree solution</p> <p>We use 2D version of Binary Index Tree. Some of the explaination can be found at <a href=https://www.topcoder.com/community/competitive-programming/tutorials/binary-indexed-trees/ >Topcoder tutorial</a></p> <p>```C++ tab="C++ BIT solution" class NumMatrix { private: vector<vector\&lt;int> > nums; vector<vector\&lt;int> > tree; int m; int n;</p> <p>public: NumMatrix(vector<vector\&lt;int>> matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) return; m = matrix.size(); n = matrix[0].size();</p> <div class=highlight><pre><span></span><code>    tree.resize(m + 1, vector&lt;int&gt;(n + 1, 0));
    nums.resize(m, vector&lt;int&gt;(n, 0));

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            update(i, j, matrix[i][j]);
        }
    }
}

void update(int row, int col, int val) {
    if (m == 0 || n == 0) return;
    int diff = val - nums[row][col];
    nums[row][col] = val;
    for (int i = row + 1; i &lt;= m; i += i &amp; (-i)) {
        for (int j = col + 1; j &lt;= n; j += j &amp; (-j)) {
            tree[i][j] += diff;
        }
    }
}

int sumRegion(int row1, int col1, int row2, int col2) {
    if (m == 0 || n == 0)
        return 0;

    return getSum(row2 + 1, col2 + 1) - getSum(row1, col2 + 1) - getSum(row2 + 1, col1) + getSum(row1, col1);
}

int getSum(int row, int col) {
    int sum = 0;
    for (int i = row; i &gt; 0; i -= i &amp; (-i)) {
        for (int j = col; j &gt; 0; j -= j &amp; (-j)) {
            sum += tree[i][j];
        }
    }

    return sum;
}
</code></pre></div> <p>};</p> <p>/*<em> * Your NumMatrix object will be instantiated and called as such: * NumMatrix obj = new NumMatrix(matrix); * obj.update(row,col,val); * int param_2 = obj.sumRegion(row1,col1,row2,col2); </em>/ <div class=highlight><pre><span></span><code>### Count of Range Sum

Solution 1 Merge sort using `inplace_merge()`

1. The core is to figure out how to calculate the result while merging. It is based
   on the fact that the left half and right half are all sorted. Using the ordering
   information we are able to locate two points in the right half `j` and `k`,
   between which will fulfill the requirement.
2. Several important points need to be made. 1) calculation of prefix sum of the
   array. The length is `n + 1` not `n`? 2) the range passed to the merge
   subroutine are open-end `[start, end)`.
3. The base case of the subrouine. It return zero becuase the case has been
   counted in the for loop, we don&#39;t need to count it again. Not because the
   base case is `0`.

```C++ tab=
class Solution {
public:
    int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) {
        int n = nums.size();
        vector&lt;long&gt; sums(n + 1, 0);

        for(int i = 0; i&lt; n; i++)
            sums[i + 1] = sums[i] + nums[i];

        return mergeSort(sums, 0, n + 1, lower, upper);
    }

    int mergeSort(vector&lt;long&gt;&amp; sums, int start, int end, int lower, int upper) {
        if(end - start &lt;= 1) return 0; // note the meaning of this 0.

        int mid = start + (end - start) / 2;
        count = mergeSort(sums, start, mid, lower, upper)
                + mergeSort(sums, mid, end, lower, upper);

        int m = mid, n = mid, count = 0;
        for(int i = start; i &lt; mid; i++) {
            while(m &lt; end &amp;&amp; sums[m] - sums[i] &lt; lower) m++;
            while(n &lt; end &amp;&amp; sums[n] - sums[i] &lt;= upper) n++;
            count += n - m;
        }

        inplace_merge(sums.begin() + start, sums.begin() + mid, sums.begin() + end);

        return count;
    }
};
</code></pre></div></p> <p>Solution 2 Merge sort using tmp buffer cache</p> <ol> <li>Here is how the count is making sense.</li> </ol> <div class=highlight><pre><span></span><code>       |--------------|-------------------|
sums:  |start         |mid                |end
       |---|----------|------|------|-----|
           i                 j      k
Because sums[j] - sums[i] &gt;= lower, and sums[k] - sums[i] &gt; upper,
So for the subarray start with i, ending index in [j, k), the range
sum is in [lower, upper]. Notice k should not be included.
</code></pre></div> <p>```C++ tab= class Solution { public: int countRangeSum(vector<int>&amp; nums, int lower, int upper) { int n = nums.size(); long sums[n + 1] = {0};</p> <div class=highlight><pre><span></span><code>    if (n == 0)
        return 0;

    for (int i = 0; i &lt; n; i++) {
        sums[i + 1] = sums[i] + nums[i];
    }

    /* n + 1 is the one pass the last element of sums */
    return countByMergeSort(sums, 0, n + 1, lower, upper);
}

/* This function will return sorted array sums[start], ... sums[end - 1] */
int countByMergeSort(long sums[], int start, int end, int lower, int upper) {
    if (end - start &lt;= 1) return 0;

    int mid = start + (end - start) / 2;
    int count = countByMergeSort(sums, start, mid, lower, upper)
                + countByMergeSort(sums, mid, end, lower, upper);

    long cache[end - start] = {0};

    int j = mid, k = mid, t = mid;
    for (int i = start, r = 0; i &lt; mid; ++i, ++r) {
        while (k &lt; end &amp;&amp; sums[k] - sums[i] &lt; lower) k++;
        while (j &lt; end &amp;&amp; sums[j] - sums[i] &lt;= upper) j++;

        count += j - k; /* calculate the result */

        /* Merge left and right to get sorted array {sums[start], .. sums[end - 1]}.
         * Because left part of sums[start] to sums[mid] are already sorted,
         * use cache here to merge prefix of the right part: sum[mid] to sums[t]
         * with left part upto sums[i] for all i = {start, mid - 1}. */
        while (t &lt; end &amp;&amp; sums[t] &lt; sums[i])
            cache[r++] = sums[t++];

        cache[r] = sums[i];

    } /* after this for loop, cache will have partially sorted array
       * cache = sums_left = {sums[start], ... sums[t - 1]} element
       * of which will be in their final sorted positions.
       * array sums_right = {sums[t], sums[end - 1]} is also
       * in their final sorted positions. */

    /* Since the sums_left is sorted, it have size of t - start,
     * here we copy exactly t - start element from cache to sums.
     */
    for (int i = start; i &lt; t; i++)
        sums[i] = cache[i - start];

    return count;
}
</code></pre></div> <p>}; ``` Solution 3 BST Solution 4 BIT </p> <h3 id=maximum-sum-of-two-non-overlapping-subarrays>Maximum Sum of Two Non-Overlapping Subarrays<a class=headerlink href=#maximum-sum-of-two-non-overlapping-subarrays title="Permanent link">&para;</a></h3> <p><code>C++ tab="Brute Force Iterate" class Solution { public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) { int n = A.size(); if (L == 0 || M == 0) { return 0; } vector&lt;int&gt; preSum(n, 0); preSum[0] = A[0]; for (int i = 1; i &lt; n; i++) { preSum[i] = preSum[i - 1] + A[i]; } int res = 0; // iterate the L using index i for (int i = 0; i &lt; n - L + 1; i++) { int Lsum = 0; if (i == 0) { Lsum = preSum[i + L - 1]; } else { Lsum = preSum[i + L - 1] - preSum[i - 1]; } int Msum = 0; // iterate the left M array using index j for (int j = 0; j &lt; i - M; j++) { int tmp = 0; if (j == 0) { tmp = preSum[j + M - 1]; } else { tmp = preSum[j + M - 1] - preSum[j - 1]; } Msum = max(Msum, tmp); } // iterate the right M array using index j for (int j = i + L; j &lt; n - M + 1; j++) { Msum = max(Msum, preSum[j + M - 1] - preSum[j - 1]); } res = max(res, Msum + Lsum); } return res; } };</code></p> <p>```C++ tab="One pass" class Solution { public: int maxSumTwoNoOverlap(vector<int>&amp; A, int L, int M) { int n = A.size(); if (L == 0 || M == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    vector&lt;int&gt; preSum(n, 0);
    preSum[0] = A[0];
    for (int i = 1; i &lt; n; i++) {
        preSum[i] = preSum[i - 1] + A[i];
    }

    int res = INT_MIN;
    int Lmax = INT_MIN;
    int Mmax = INT_MIN;
    //
    for (int i = L + M; i &lt;= n; i++) {
        // L is front, M is back
        if (i == L + M) {
            Lmax = preSum[L - 1];
        } else {
            Lmax = max(Lmax, preSum[i - M - 1] - preSum[i - L - M - 1]);
        }
        // M is front, L is back
        if (i == L + M) {
            Mmax = preSum[M - 1];
        } else {
            Mmax = max(Mmax, preSum(i - L - 1) - preSum[i - M - L - 1]);
        }

        res = max({res,
                   Lmax + preSum[i - 1] - preSum[i - M - 1],
                   Mmax + preSum[i - 1] - preSum[i - L - 1]})
    }
    return res;
}
</code></pre></div> <p>}; <code></code>C++ tab="DP solution" //TODO ```</p> <h3 id=maximum-sum-of-3-non-overlapping-subarrays>Maximum Sum of 3 Non-Overlapping Subarrays<a class=headerlink href=#maximum-sum-of-3-non-overlapping-subarrays title="Permanent link">&para;</a></h3> <h3 id=longest-substring-without-repeating-characters><a href=../../string/notes/#longest-substring-without-repeating-characters>Longest Substring Without Repeating Characters</a><a class=headerlink href=#longest-substring-without-repeating-characters title="Permanent link">&para;</a></h3> <h3 id=longest-substring-with-at-most-two-distinct-characters><a href=../../string/notes/#longest-substring-with-at-most-two-distinct-characters>Longest Substring with At Most Two Distinct Characters</a><a class=headerlink href=#longest-substring-with-at-most-two-distinct-characters title="Permanent link">&para;</a></h3> <h3 id=longest-substring-with-at-most-k-distinct-characters><a href=../../string/notes/#longest-substring-with-at-most-k-distinct-characters>Longest Substring with At Most K Distinct Characters</a><a class=headerlink href=#longest-substring-with-at-most-k-distinct-characters title="Permanent link">&para;</a></h3> <h3 id=subarrays-with-k-different-integers>Subarrays with K Different Integers<a class=headerlink href=#subarrays-with-k-different-integers title="Permanent link">&para;</a></h3> <ul> <li>If you use sliding window to solve this problem, there are lots of corner cases.</li> <li>for example: <code>[1, 1, 2, 1, 2, 1, 3, 1], K = 2</code>, how can you ensure you count all the subarray?</li> <li>Remember this trick that you can use the <code>atMostKDistinct(A, K) - atMostKDistinct(A, K - 1)</code>.</li> </ul> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>subarraysWithKDistinct</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>A</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nf>subarrayWithAtMostKDistinct</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>K</span><span class=p>)</span>
                 <span class=o>-</span> <span class=n>subarrayWithAtMostKDistinct</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>K</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=kt>int</span> <span class=n>subarrayWithAtMostKDistinct</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>A</span><span class=p>,</span> <span class=kt>int</span> <span class=n>K</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>count</span><span class=p>;</span>

        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>A</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=o>++</span><span class=n>j</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>count</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]]</span><span class=o>++</span><span class=p>)</span> <span class=n>K</span><span class=o>--</span><span class=p>;</span>
            <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=o>!--</span><span class=n>count</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>j</span><span class=p>]])</span> <span class=n>K</span><span class=o>++</span><span class=p>;</span>
                <span class=n>i</span><span class=o>++</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=n>res</span> <span class=o>+=</span> <span class=n>j</span> <span class=o>-</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <h3 id=number-of-substrings-containing-all-three-characters>Number of Substrings Containing All Three Characters<a class=headerlink href=#number-of-substrings-containing-all-three-characters title="Permanent link">&para;</a></h3> <h3 id=count-number-of-nice-subarrays>Count Number of Nice Subarrays<a class=headerlink href=#count-number-of-nice-subarrays title="Permanent link">&para;</a></h3> <h3 id=replace-the-substring-for-balanced-string>Replace the Substring for Balanced String<a class=headerlink href=#replace-the-substring-for-balanced-string title="Permanent link">&para;</a></h3> <h3 id=binary-subarrays-with-sum>Binary Subarrays With Sum<a class=headerlink href=#binary-subarrays-with-sum title="Permanent link">&para;</a></h3> <h3 id=fruit-into-baskets>Fruit Into Baskets<a class=headerlink href=#fruit-into-baskets title="Permanent link">&para;</a></h3> <h3 id=shortest-subarray-with-sum-at-least-k>Shortest Subarray with Sum at Least K<a class=headerlink href=#shortest-subarray-with-sum-at-least-k title="Permanent link">&para;</a></h3> <h3 id=minimum-size-subarray-sum_1><a href=#minimum-size-subarray-sum>Minimum Size Subarray Sum</a><a class=headerlink href=#minimum-size-subarray-sum_1 title="Permanent link">&para;</a></h3> <h3 id=substring-with-concatenation-of-all-words>Substring with Concatenation of All Words<a class=headerlink href=#substring-with-concatenation-of-all-words title="Permanent link">&para;</a></h3> <h3 id=max-consecutive-ones-ii>Max Consecutive Ones II<a class=headerlink href=#max-consecutive-ones-ii title="Permanent link">&para;</a></h3> <h3 id=max-consecutive-ones-iii>Max Consecutive Ones III<a class=headerlink href=#max-consecutive-ones-iii title="Permanent link">&para;</a></h3> <h2 id=category-4-k-sum-problems>Category 4 K Sum problems<a class=headerlink href=#category-4-k-sum-problems title="Permanent link">&para;</a></h2> <h3 id=two-sum>Two Sum<a class=headerlink href=#two-sum title="Permanent link">&para;</a></h3> <h3 id=two-sum-ii-input-array-is-sorted>Two Sum II - Input array is sorted<a class=headerlink href=#two-sum-ii-input-array-is-sorted title="Permanent link">&para;</a></h3> <h3 id=two-sum-iii-data-structure-design>Two Sum III - Data structure design<a class=headerlink href=#two-sum-iii-data-structure-design title="Permanent link">&para;</a></h3> <h3 id=two-sum-iv-input-is-a-bst>Two Sum IV - Input is a BST<a class=headerlink href=#two-sum-iv-input-is-a-bst title="Permanent link">&para;</a></h3> <h3 id=3sum>3Sum<a class=headerlink href=#3sum title="Permanent link">&para;</a></h3> <h3 id=3sum-closest>3Sum Closest<a class=headerlink href=#3sum-closest title="Permanent link">&para;</a></h3> <h3 id=3sum-smaller>3Sum Smaller<a class=headerlink href=#3sum-smaller title="Permanent link">&para;</a></h3> <h3 id=4sum>4Sum<a class=headerlink href=#4sum title="Permanent link">&para;</a></h3> <h3 id=4sum-ii>4Sum II<a class=headerlink href=#4sum-ii title="Permanent link">&para;</a></h3> <h3 id=k-sum>K Sum<a class=headerlink href=#k-sum title="Permanent link">&para;</a></h3> <h3 id=target-sum>Target Sum<a class=headerlink href=#target-sum title="Permanent link">&para;</a></h3> <h2 id=cagegory-5-2d-arry-matrix-grid-problems>Cagegory 5 2D arry (matrix, grid) problems<a class=headerlink href=#cagegory-5-2d-arry-matrix-grid-problems title="Permanent link">&para;</a></h2> <h3 id=perfect-rectangle>Perfect Rectangle<a class=headerlink href=#perfect-rectangle title="Permanent link">&para;</a></h3> <h3 id=trapping-rain-water>Trapping Rain Water<a class=headerlink href=#trapping-rain-water title="Permanent link">&para;</a></h3> <h3 id=trapping-rain-water-ii>Trapping Rain Water II<a class=headerlink href=#trapping-rain-water-ii title="Permanent link">&para;</a></h3> <h3 id=container-with-most-water>Container With Most Water<a class=headerlink href=#container-with-most-water title="Permanent link">&para;</a></h3> <h3 id=largest-rectangle-in-histogram>Largest Rectangle in Histogram<a class=headerlink href=#largest-rectangle-in-histogram title="Permanent link">&para;</a></h3> <h3 id=maximal-rectangle_1>Maximal Rectangle<a class=headerlink href=#maximal-rectangle_1 title="Permanent link">&para;</a></h3> <h3 id=maximal-square_1>Maximal Square<a class=headerlink href=#maximal-square_1 title="Permanent link">&para;</a></h3> <h3 id=the-skyline-problem>The Skyline Problem<a class=headerlink href=#the-skyline-problem title="Permanent link">&para;</a></h3> <h3 id=smallest-rectangle-enclosing-black-pixels>Smallest Rectangle Enclosing Black Pixels<a class=headerlink href=#smallest-rectangle-enclosing-black-pixels title="Permanent link">&para;</a></h3> <h3 id=rectangle-area>Rectangle Area<a class=headerlink href=#rectangle-area title="Permanent link">&para;</a></h3> <h3 id=max-sum-of-rectangle-no-larger-than-k_1><a href=#max-sum-of-rectangle-no-larger-than-k>Max Sum of Rectangle No Larger Than K</a><a class=headerlink href=#max-sum-of-rectangle-no-larger-than-k_1 title="Permanent link">&para;</a></h3> <h2 id=category-6-stock-buying-problems>Category 6 stock buying problems<a class=headerlink href=#category-6-stock-buying-problems title="Permanent link">&para;</a></h2> <p><a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems>Most consistent ways of dealing with the series of stock problems</a></p> <h3 id=121-best-time-to-buy-and-sell-stock>121. Best Time to Buy and Sell Stock<a class=headerlink href=#121-best-time-to-buy-and-sell-stock title="Permanent link">&para;</a></h3> <p>Solution 1 O(n) one pass to find the minimum and in the meantime, find the max profit.</p> <p>```C++ tab= class Solution { public: int maxProfit(vector<int> &amp;prices) { int n = prices.size(); if (n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    int res = 0, low = prices[0];

    for (int i = 1; i &lt; n; i++) {
        res = max(res, prices[i] - low);
        low = min(low, prices[i]);
    }

    return res;
}
</code></pre></div> <p>}; ``` </p> <h3 id=122-best-time-to-buy-and-sell-stock-ii>122. Best Time to Buy and Sell Stock II<a class=headerlink href=#122-best-time-to-buy-and-sell-stock-ii title="Permanent link">&para;</a></h3> <p>Solution 1 Greedy since you can buy as many times as you can <code>C++ tab= class Solution { public: int maxProfit(vector&lt;int&gt; &amp;prices) { int n = prices.size(); int res = 0; for (int i = 0; i &lt; n - 1; i++) { if (prices[i + 1] - prices[i]) { res += prices[i + 1] - prices[i]; } } return res; } };</code></p> <h3 id=123-best-time-to-buy-and-sell-stock-iii>123. Best Time to Buy and Sell Stock III<a class=headerlink href=#123-best-time-to-buy-and-sell-stock-iii title="Permanent link">&para;</a></h3> <p>You can now buy at most twice. how to max the profit.</p> <p>Solution 1 Dynamic programming</p> <ul> <li>5 stages: 1. before buy the first &lt;-- optimal solution could be at this stage 2. hold the first 3. sell the first &lt;-- or at this stage, only bought once, 4. hold the second 5. sell the second &lt;-- or at this stage, bought twice.</li> </ul> <p>```C++ tab= class Solution { public: int maxProfit(vector<int> &amp;A) { //1, 3, 5: // f[i][j] = max{f[i - 1][j], f[i - 1][j - 1] + A[i - 1] - A[i - 2]} // 2, 4: // f[i][j] = max{f[i - 1][j] + A[i - 1] - A[i - 2], // f[i - 1][j - 1], f[i - 1][j - 2] + A[i - 1] - A[i - 2]} int n = A.size(); if (n == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    int f[n+1][6];

    /* init */
    f[0][1] = 0;
    f[0][2] = f[0][3] = f[0][4] = f[0][5] = INT_MIN;

    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= 5; j += 2) {
            f[i][j] = f[i - 1][j];
            if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; f[i - 1][j - 1] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + A[i - 1] - A[i - 2]);
            }

        }

        for (int j = 2; j &lt; 5; j += 2) {
            f[i][j] = f[i - 1][j - 1];
            if (i &gt; 1 &amp;&amp; f[i - 1][j] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j] + A[i - 1] - A[i - 2]);
            }

            if (i &gt; 1 &amp;&amp; j &gt; 2 &amp;&amp; f[i - 1][j - 2] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j - 2] + A[i - 1] - A[i - 2]);
            }
        }
    }

    return max(f[n][1], max(f[n][3], f[n][5]));
}
</code></pre></div> <p>}; <code>Solution 2 Use `T[i][k][j]` to represent the maximum profit of first i days if we allow at most k transactions and the current number of stocks at hand is `j` (`j == 0, 1` because hold two stocks at the same time is not allowed). So we have:</code>text T[i][2][0] = max(T[i - 1][2][0], T[i - 1][2][1] + prices[i - 1]); T[i][2][1] = max(T[i - 1][2][1], T[i - 1][1][0] - prices[i - 1]); T[i][1][0] = max(T[i - 1][1][0], T[i - 1][1][1] + prices[i - 1]); T[i][1][1] = max(T[i - 1][1][1], T[i - 1][0][0] - prices[i - 1]); ```</p> <p>Think: How to ensure you fourmular cover all the possible values?</p> <h3 id=188-best-time-to-buy-and-sell-stock-iv>188. Best Time to Buy and Sell Stock IV<a class=headerlink href=#188-best-time-to-buy-and-sell-stock-iv title="Permanent link">&para;</a></h3> <h3 id=309-best-time-to-buy-and-sell-stock-with-cooldown>309. Best Time to Buy and Sell Stock with Cooldown<a class=headerlink href=#309-best-time-to-buy-and-sell-stock-with-cooldown title="Permanent link">&para;</a></h3> <h3 id=714-best-time-to-buy-and-sell-stock-with-transaction-fee>714. Best Time to Buy and Sell Stock with Transaction Fee<a class=headerlink href=#714-best-time-to-buy-and-sell-stock-with-transaction-fee title="Permanent link">&para;</a></h3> <h3 id=determine-the-buy-data-and-sell-data-of-maximum-profit-dd-139>Determine the buy data and sell data of maximum profit (DD 139)<a class=headerlink href=#determine-the-buy-data-and-sell-data-of-maximum-profit-dd-139 title="Permanent link">&para;</a></h3> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../../ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Index </div> </div> </a> <a href=../../backtracking/notes/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Backtracking </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Rui Han </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.77e55a48.min.js></script> <script src=../../../assets/javascripts/bundle.9554a270.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>