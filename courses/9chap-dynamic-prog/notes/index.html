<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://ruihan.org/courses/9chap-dynamic-prog/notes/ rel=canonical><link rel="shortcut icon" href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.1.2, mkdocs-material-6.0.2"><title>Nine Chapter Dynamic Programming - RUIHAN.ORG</title><link rel=stylesheet href=../../../assets/stylesheets/main.38780c08.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.3f72e892.min.css><meta name=theme-color content=#000000><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=black data-md-color-accent=black> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#nine-chapter-dynamic-programming class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=https://ruihan.org title=RUIHAN.ORG class="md-header-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> RUIHAN.ORG </span> <span class="md-header-nav__topic md-ellipsis"> Nine Chapter Dynamic Programming </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class="md-tabs md-tabs--active" aria-label=Tabs data-md-component=tabs> <div class="md-tabs__inner md-grid"> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../../books/ class=md-tabs__link> Books </a> </li> <li class=md-tabs__item> <a href=../../ class="md-tabs__link md-tabs__link--active"> Courses </a> </li> <li class=md-tabs__item> <a href=../../../leetcode/ class=md-tabs__link> Leetcode </a> </li> <li class=md-tabs__item> <a href=../../../research/ class=md-tabs__link> Research </a> </li> <li class=md-tabs__item> <a href=../../../seedlabs/ class=md-tabs__link> SEED Labs </a> </li> <li class=md-tabs__item> <a href=../../../system-design/ class=md-tabs__link> System Design </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=https://ruihan.org title=RUIHAN.ORG class="md-nav__button md-logo" aria-label=RUIHAN.ORG> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg> </a> RUIHAN.ORG </label> <div class=md-nav__source> <a href=https://github.com/iurnah/ruihan.org title="Go to repository" class=md-source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg> </div> <div class=md-source__repository> iurnah/ruihan.org </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-1 type=checkbox id=nav-1> <label class=md-nav__link for=nav-1> Books <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Books data-md-level=1> <label class=md-nav__title for=nav-1> <span class="md-nav__icon md-icon"></span> Books </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../books/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../books/accelerated-cpp/notes/ class=md-nav__link> Accelerated C++ </a> </li> <li class=md-nav__item> <a href=../../../books/mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Datasets </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2 checked> <label class=md-nav__link for=nav-2> Courses <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Courses data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Courses </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../machine-learning-coursera/notes/ class=md-nav__link> Machine Learning (Coursera) </a> </li> <li class=md-nav__item> <a href=../../cs224n/lec-notes/ class=md-nav__link> CS224N Lecture Notes </a> </li> <li class=md-nav__item> <a href=../../cs224n/write-up/ class=md-nav__link> CS224N Write-up </a> </li> <li class=md-nav__item> <a href=../../coursera-dl4-cnn/notes/ class=md-nav__link> Convolutional Neural Networks </a> </li> <li class=md-nav__item> <a href=../../mining-massive-datasets/notes/ class=md-nav__link> Mining Massive Data Sets </a> </li> <li class=md-nav__item> <a href=../../6.431-probability/notes/ class=md-nav__link> 6.431 Probability </a> </li> <li class=md-nav__item> <a href=../../learning-from-data/notes.md class=md-nav__link> Learning From Data </a> </li> <li class=md-nav__item> <a href=../../9chap-system-design/notes/ class=md-nav__link> Nine Chapter System Design </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Nine Chapter Dynamic Programming <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Nine Chapter Dynamic Programming </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#lecture-1-introduction-to-dynamic-programming class=md-nav__link> Lecture 1 Introduction to Dynamic Programming </a> <nav class=md-nav aria-label="Lecture 1 Introduction to Dynamic Programming"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#coin-change class=md-nav__link> Coin Change </a> </li> <li class=md-nav__item> <a href=#unique-paths class=md-nav__link> Unique Paths </a> </li> <li class=md-nav__item> <a href=#jump-game class=md-nav__link> Jump Game </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-2-dynamic-programming-on-coordinates class=md-nav__link> Lecture 2 Dynamic Programming on Coordinates </a> <nav class=md-nav aria-label="Lecture 2 Dynamic Programming on Coordinates"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#paint-house class=md-nav__link> Paint House </a> </li> <li class=md-nav__item> <a href=#decode-ways class=md-nav__link> Decode Ways </a> </li> <li class=md-nav__item> <a href=#longest-increasing-continuous-subsequence class=md-nav__link> Longest Increasing Continuous Subsequence </a> </li> <li class=md-nav__item> <a href=#minimum-path-sum class=md-nav__link> Minimum Path Sum </a> </li> <li class=md-nav__item> <a href=#bomb-enemy class=md-nav__link> Bomb Enemy </a> </li> <li class=md-nav__item> <a href=#counting-bits class=md-nav__link> Counting Bits </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-3-dynamic-programming-on-sequences class=md-nav__link> Lecture 3 Dynamic Programming on Sequences </a> <nav class=md-nav aria-label="Lecture 3 Dynamic Programming on Sequences"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 序列型动态规划 </a> </li> <li class=md-nav__item> <a href=#paint-house-ii class=md-nav__link> Paint House II </a> </li> <li class=md-nav__item> <a href=#house-robber class=md-nav__link> House Robber </a> </li> <li class=md-nav__item> <a href=#house-robber-ii class=md-nav__link> House Robber II </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock class=md-nav__link> Best Time to Buy and Sell Stock </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-ii class=md-nav__link> Best Time to Buy and Sell Stock II </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-iii class=md-nav__link> Best Time to Buy and Sell Stock III </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-iv class=md-nav__link> Best Time to Buy and Sell Stock IV </a> </li> <li class=md-nav__item> <a href=#longest-increasing-subsequence class=md-nav__link> Longest Increasing Subsequence </a> </li> <li class=md-nav__item> <a href=#russian-doll-envelopes class=md-nav__link> Russian Doll Envelopes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-4 class=md-nav__link> Lecture 4 </a> <nav class=md-nav aria-label="Lecture 4"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#copy-books class=md-nav__link> Copy Books </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-7 class=md-nav__link> Lecture 7 </a> <nav class=md-nav aria-label="Lecture 7"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#403-frog-jump class=md-nav__link> 403. Frog Jump </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../func-prog-in-scala/notes/ class=md-nav__link> Functional Programming Principles in Scala </a> </li> <li class=md-nav__item> <a href=../../applied-scrum-for-agile/notes/ class=md-nav__link> Applied Scrum for Agile Project Management </a> </li> <li class=md-nav__item> <a href=../../concurrent-prog-java/notes/ class=md-nav__link> Concurrent Programming in Java </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3> <label class=md-nav__link for=nav-3> Leetcode <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Leetcode data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> Leetcode </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../leetcode/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../leetcode/array/notes/ class=md-nav__link> Array </a> </li> <li class=md-nav__item> <a href=../../../leetcode/backtracking/notes/ class=md-nav__link> Backtracking </a> </li> <li class=md-nav__item> <a href=../../../leetcode/binary-search/notes/ class=md-nav__link> Binary Search </a> </li> <li class=md-nav__item> <a href=../../../leetcode/breadth-first-search/notes/ class=md-nav__link> Breadth-First Search (BFS) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/depth-first-search/notes/ class=md-nav__link> Depth-First Search (DFS) </a> </li> <li class=md-nav__item> <a href=../../../leetcode/dynamic-programming/notes/ class=md-nav__link> Dynamic Programming </a> </li> <li class=md-nav__item> <a href=../../../leetcode/graph/notes/ class=md-nav__link> Graph </a> </li> <li class=md-nav__item> <a href=../../../leetcode/heap/notes/ class=md-nav__link> Heap </a> </li> <li class=md-nav__item> <a href=../../../leetcode/interval/notes/ class=md-nav__link> Interval </a> </li> <li class=md-nav__item> <a href=../../../leetcode/linked-list/notes/ class=md-nav__link> Linked List </a> </li> <li class=md-nav__item> <a href=../../../leetcode/math/notes/ class=md-nav__link> Math </a> </li> <li class=md-nav__item> <a href=../../../leetcode/stack/notes/ class=md-nav__link> Stack </a> </li> <li class=md-nav__item> <a href=../../../leetcode/string/notes/ class=md-nav__link> String </a> </li> <li class=md-nav__item> <a href=../../../leetcode/tree/notes/ class=md-nav__link> Tree </a> </li> <li class=md-nav__item> <a href=../../../leetcode/trie/notes/ class=md-nav__link> Trie </a> </li> <li class=md-nav__item> <a href=../../../leetcode/union-find/notes/ class=md-nav__link> Union Find </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-4 type=checkbox id=nav-4> <label class=md-nav__link for=nav-4> Research <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Research data-md-level=1> <label class=md-nav__title for=nav-4> <span class="md-nav__icon md-icon"></span> Research </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../research/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../research/paper-reading/notes/ class=md-nav__link> Paper Reading </a> </li> <li class=md-nav__item> <a href=../../../research/coalition-game/notes/ class=md-nav__link> Coalition Game </a> </li> <li class=md-nav__item> <a href=../../../research/contextual-bandit/notes/ class=md-nav__link> Contextual Multi-Armed Bandit </a> </li> <li class=md-nav__item> <a href=../../../research/tfidf-score/notes/ class=md-nav__link> TF-IDF for Information Retrieval </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-5 type=checkbox id=nav-5> <label class=md-nav__link for=nav-5> SEED Labs <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="SEED Labs" data-md-level=1> <label class=md-nav__title for=nav-5> <span class="md-nav__icon md-icon"></span> SEED Labs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../seedlabs/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/applied-crypto/notes/ class=md-nav__link> Applied Cryptograph Notes </a> </li> <li class=md-nav__item> <a href=../../../seedlabs/public-key-cryptography-and-pki/notes/ class=md-nav__link> Public Key Cryptography and PKI </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-6 type=checkbox id=nav-6> <label class=md-nav__link for=nav-6> System Design <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="System Design" data-md-level=1> <label class=md-nav__title for=nav-6> <span class="md-nav__icon md-icon"></span> System Design </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../system-design/ class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=../../../system-design/browser/notes.md class=md-nav__link> How Browser Works </a> </li> <li class=md-nav__item> <a href=../../../system-design/concurrency/notes/ class=md-nav__link> Concurrency and Synchronization </a> </li> <li class=md-nav__item> <a href=../../../system-design/concepts/notes/ class=md-nav__link> Distributed System Concepts </a> </li> <li class=md-nav__item> <a href=../../../system-design/patterns/notes/ class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/tinyurl/notes/ class=md-nav__link> How to Design TinyUrl </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/twitter/notes/ class=md-nav__link> How to Design Twitter </a> </li> <li class=md-nav__item> <a href=../../../system-design/problems/ticketmaster/notes/ class=md-nav__link> How to Design Ticketmaster </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#lecture-1-introduction-to-dynamic-programming class=md-nav__link> Lecture 1 Introduction to Dynamic Programming </a> <nav class=md-nav aria-label="Lecture 1 Introduction to Dynamic Programming"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#coin-change class=md-nav__link> Coin Change </a> </li> <li class=md-nav__item> <a href=#unique-paths class=md-nav__link> Unique Paths </a> </li> <li class=md-nav__item> <a href=#jump-game class=md-nav__link> Jump Game </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-2-dynamic-programming-on-coordinates class=md-nav__link> Lecture 2 Dynamic Programming on Coordinates </a> <nav class=md-nav aria-label="Lecture 2 Dynamic Programming on Coordinates"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#paint-house class=md-nav__link> Paint House </a> </li> <li class=md-nav__item> <a href=#decode-ways class=md-nav__link> Decode Ways </a> </li> <li class=md-nav__item> <a href=#longest-increasing-continuous-subsequence class=md-nav__link> Longest Increasing Continuous Subsequence </a> </li> <li class=md-nav__item> <a href=#minimum-path-sum class=md-nav__link> Minimum Path Sum </a> </li> <li class=md-nav__item> <a href=#bomb-enemy class=md-nav__link> Bomb Enemy </a> </li> <li class=md-nav__item> <a href=#counting-bits class=md-nav__link> Counting Bits </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-3-dynamic-programming-on-sequences class=md-nav__link> Lecture 3 Dynamic Programming on Sequences </a> <nav class=md-nav aria-label="Lecture 3 Dynamic Programming on Sequences"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 序列型动态规划 </a> </li> <li class=md-nav__item> <a href=#paint-house-ii class=md-nav__link> Paint House II </a> </li> <li class=md-nav__item> <a href=#house-robber class=md-nav__link> House Robber </a> </li> <li class=md-nav__item> <a href=#house-robber-ii class=md-nav__link> House Robber II </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock class=md-nav__link> Best Time to Buy and Sell Stock </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-ii class=md-nav__link> Best Time to Buy and Sell Stock II </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-iii class=md-nav__link> Best Time to Buy and Sell Stock III </a> </li> <li class=md-nav__item> <a href=#best-time-to-buy-and-sell-stock-iv class=md-nav__link> Best Time to Buy and Sell Stock IV </a> </li> <li class=md-nav__item> <a href=#longest-increasing-subsequence class=md-nav__link> Longest Increasing Subsequence </a> </li> <li class=md-nav__item> <a href=#russian-doll-envelopes class=md-nav__link> Russian Doll Envelopes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-4 class=md-nav__link> Lecture 4 </a> <nav class=md-nav aria-label="Lecture 4"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#copy-books class=md-nav__link> Copy Books </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#lecture-7 class=md-nav__link> Lecture 7 </a> <nav class=md-nav aria-label="Lecture 7"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#403-frog-jump class=md-nav__link> 403. Frog Jump </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=nine-chapter-dynamic-programming>Nine Chapter Dynamic Programming<a class=headerlink href=#nine-chapter-dynamic-programming title="Permanent link">&para;</a></h1> <ul> <li><a href=https://wiki.rui-han.com/index.php/Private:Courses/Languages_and_Algorithms/Nine_Chapter_Dynamic_Programming_Course>Nine Chapter Dynamic Programming Course</a></li> </ul> <h2 id=lecture-1-introduction-to-dynamic-programming>Lecture 1 Introduction to Dynamic Programming<a class=headerlink href=#lecture-1-introduction-to-dynamic-programming title="Permanent link">&para;</a></h2> <table> <thead> <tr> <th>Problem</th> <th>Category</th> </tr> </thead> <tbody> <tr> <td><a href=#coin-change>Coin Change</a></td> <td></td> </tr> <tr> <td><a href=#unique-paths>Unique Paths</a></td> <td>coordinate</td> </tr> <tr> <td><a href=#jump-game>Jump Game</a></td> <td></td> </tr> </tbody> </table> <ol> <li>动态规划题目特点:<ol> <li>计数<ul> <li>有多少种方式走到右下角</li> <li>有多少种方法选出k个数使得和是Sum</li> </ul> </li> <li>求最大最小值<ul> <li>从左上角走到右下角路径的最大数字和</li> <li>最长上升子序列长度</li> </ul> </li> <li>求存在性<ul> <li>取石子游戏，先手是否必胜</li> <li>能不能选出k个数使得和是Sum</li> </ul> </li> </ol> </li> <li>状态是动态规划定海神针，确定状态需要两个基本意识：<ul> <li>最后一步</li> <li>子问题</li> </ul> </li> </ol> <div class="admonition note"> <p class=admonition-title>Four Ingredients for DP</p> <ol> <li>What's the state?<ul> <li>start with the last step for the optimal solution</li> <li>decompose into subproblems</li> </ul> </li> <li>Write the state transition?<ul> <li>find the transition from subproblem relations</li> </ul> </li> <li>Initial value and boundary conditions<ul> <li>need to think careful in this step</li> </ul> </li> <li>How can you compute the states?<ul> <li>iteration directio</li> <li>forward computing</li> </ul> </li> </ol> </div> <h3 id=coin-change>Coin Change<a class=headerlink href=#coin-change title="Permanent link">&para;</a></h3> <ul> <li>Imagine the last coin you can use and the minimum solution is found can be represented as <code>f[amount]</code>. It can be solved by solving the smaller problem first. we have <code>f[amount] = min(f[amount], f[amount - last\_coin] + 1)</code>.</li> <li>The problem is we don't know which coin will be selected for the last one to reach the solution, so we have to iterate throught the coins to check every one of them. We expecting to see two <code>for</code> loops in our code.</li> <li>DP 4 ingredient:<ol> <li>size of the dp array <code>f[amount + 1]</code></li> <li>initial state: <code>f[0] = 0</code>, amount 0 can use 0 coin.</li> <li>subproblem: <code>f[amount] = min(f[amount], f[amount - last\_coin] + 1)</code>.</li> <li>results: <code>f[amount]</code></li> </ol> </li> </ul> <p>```C++ tab= class Solution { public: int coinChange(vector<int>&amp; coins , int amount) { int n = coins.size(); int f[amount + 1]; f[0] = 0;</p> <div class=highlight><pre><span></span><code>    /* calculate the f[1], f[2], ... f[amount] */
    for (int i = 1; i &lt;= amount; i++) {
        f[i] = INT_MAX;  /* small trick, set to invalid first */
        for (int j = 0; j &lt; n; j++) { /* update states */
            /* f[i] can select coins[j] &amp;&amp; f[i - coins[j]] is possible &amp;&amp; coins[j] is last coin */
            if (i &gt;= coins[j] &amp;&amp; f[i - coins[j]] != INT_MAX &amp;&amp; f[i - coins[j]] + 1 &lt; f[i]) {
                f[i] = f[i - coins[j]] + 1;
            }
        }
    }

    return f[amount] == INT_MAX ? -1 : f[amount];
}
</code></pre></div> <p>}; <code></code>C++ tab="Alternative Solution" class Solution { public: int coinChange(vector<int>&amp; coins, int amount) { int n = coins.size(); int f[amount+1]; // f[i] represent the minimum counts to make up i amount // use INT_MAX to represent impossible case. f[0] = 0; for (int i = 1; i &lt;= amount; i++) { f[i] = INT_MAX; for (int j = 0; j &lt; n; j++) { if (i &gt;= coins[j] &amp;&amp; f[i - coins[j]] != INT_MAX) { f[i] = min(f[i], f[i - coins[j]] + 1); } } } return f[amount] == INT_MAX ? -1 : f[amount]; } }; ```</p> <h3 id=unique-paths>Unique Paths<a class=headerlink href=#unique-paths title="Permanent link">&para;</a></h3> <ul> <li>Solving smaller problem first than by accumulating the results from the smaller problems, we can solve the the overall problem.</li> <li>Use a 2-d array to record the result the smaller problem, we know for the position <code>f[i][j] = f[i - 1][j] + f[i][j - 1]</code>, which which mean the summation of number of path from above and from left.</li> <li>The initial state is the first row and the first column are all equal to <code>1</code>. </li> </ul> <p>```C++ tab= class Solution { public: /*<em> * @param n, m: positive integer (1 &lt;= n ,m &lt;= 100) * @return an integer </em>/ int uniquePaths(int m, int n) { int f[m][n] = {0};</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (i == 0 || j == 0) {
                f[i][j] = 1;
            }

            if (i &gt; 0 &amp;&amp; j &gt; 0) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
    }

    return f[m - 1][n - 1];

}
</code></pre></div> <p>}; ``` </p> <h3 id=jump-game>Jump Game<a class=headerlink href=#jump-game title="Permanent link">&para;</a></h3> <ul> <li>Notice the problem statement "Each element in the array represents your maximum jump length at that position." Solution 1 DP </li> <li>The problem have characteristics of the dynamic problem, that is it can be decomposed into smaller problem, the large problem can be solved using the result from solving smaller problems.</li> <li>We use a dp array <code>f[i]</code> to store whether it can jump from previous position to position <code>i</code>. if <code>nums[i] + i &gt;= j</code>, it can also jump to position <code>j</code>.</li> <li>Looks like we are going to have a nested loop. the outer loop iterate to check whether can jump to each step <code>j</code>. inner loop check each step before <code>j</code>, namely the smaller size problem. <code>C++ tab= class Solution { public: bool canJump(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 0) return true; int f[n]; f[0] = true; /* initialize */ for (int j = 1; j &lt; n; j++) { f[j] = false; for (int i = 0; i &lt; j; i++) { if (f[i] &amp;&amp; nums[i] + i &gt;= j) { f[j] = true; break; } } } return f[n - 1]; } };</code></li> </ul> <p>Solution 2 Greedy</p> <ul> <li>Use a variable <code>cur_max</code> to maintain the possible maximum jump position, if the current position is less than the maximum possible jump, return flase.</li> </ul> <p>```C++ tab= class Solution { public: bool canJump(vector<int>&amp; nums) { int n = nums.size(); if (n == 0) return true;</p> <div class=highlight><pre><span></span><code>    int cur_max = nums[0]; /* maximum distance can reach from ith */
    /* L.I.: current step (ith step) must &lt;= cur_max jump */
    for (int i = 0; i &lt; n; i++) {
        if (i &gt; cur_max) /* must goes first */
            return false;

        if (i + nums[i] &gt; cur_max)
            cur_max = i + nums[i];
    }

    return true;
}
</code></pre></div> <p>}; ``` </p> <h2 id=lecture-2-dynamic-programming-on-coordinates>Lecture 2 Dynamic Programming on Coordinates<a class=headerlink href=#lecture-2-dynamic-programming-on-coordinates title="Permanent link">&para;</a></h2> <table> <thead> <tr> <th>Problem</th> <th>Category</th> </tr> </thead> <tbody> <tr> <td><a href=#unique-paths-ii>Unique Paths II</a></td> <td>坐标型</td> </tr> <tr> <td><a href=#paint-house>Paint House</a></td> <td>序列型 ＋ 状态</td> </tr> <tr> <td><a href=#decode-ways>Decode Ways</a></td> <td>划分型</td> </tr> <tr> <td><a href=#longest-increasing-continuous-subsequence>Longest Increasing Continuous Subsequence</a></td> <td>序列型 / 划分型</td> </tr> <tr> <td><a href=#minimum-path-sum>Minimum Path Sum</a></td> <td>坐标型</td> </tr> <tr> <td><a href=#bomb-enemy>Bomb Enemy</a></td> <td>坐标型</td> </tr> <tr> <td><a href=#counting-bits>Counting Bits</a></td> <td>坐标型</td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>### 坐标型动态规划</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>* 最简单的动态规划类型</td> <td></td> </tr> <tr> <td>* 给定一个序列或网格</td> <td></td> </tr> <tr> <td>* 需要找到序列中某个/些子序列或网格中的某条路径</td> <td></td> </tr> <tr> <td>1. 某种性质最大/最小</td> <td></td> </tr> <tr> <td>1. 计数</td> <td></td> </tr> <tr> <td>1. 存在性</td> <td></td> </tr> <tr> <td>* 动态规划方程<code>f[i]</code>中的下标<code>i</code>表示以<code>a[i]</code>为结尾的满足条件的子序列的性质. <code>f[i][j]</code> 中的</td> <td></td> </tr> <tr> <td>下标 <code>i</code>, <code>j</code> 表示以格子<code>(i, j)</code>为结尾的满足条件的路径的性质</td> <td></td> </tr> <tr> <td>1. 最大值/最小值</td> <td></td> </tr> <tr> <td>2. 个数</td> <td></td> </tr> <tr> <td>3. 是否存在</td> <td></td> </tr> <tr> <td>* 坐标型动态规划的初始条件<code>f[0]</code>就是指以<code>a[0]</code>为结尾的子序列的性质</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>### Unique Paths II</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>```C++ tab="C++ Naive DP"</td> <td></td> </tr> <tr> <td>class Solution {</td> <td></td> </tr> <tr> <td>public:</td> <td></td> </tr> <tr> <td>int uniquePathsWithObstacles(vector<vector\&lt;int>>&amp; obstacleGrid) {</td> <td></td> </tr> <tr> <td>int m = obstacleGrid.size();</td> <td></td> </tr> <tr> <td>int n = obstacleGrid[0].size();</td> <td></td> </tr> <tr> <td>int i = 0;</td> <td></td> </tr> <tr> <td>int j = 0;</td> <td></td> </tr> <tr> <td>int flag = 0;</td> <td></td> </tr> <tr> <td>vector<vector\&lt;int>> f(m, vector<int>(n));</td> <td></td> </tr> <tr> <td>if (m == 0</td> <td></td> </tr> <tr> <td>return 0;</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>if (obstacleGrid[0][0] == 1) {</td> <td></td> </tr> <tr> <td>return 0;</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>f[0][0] = 1;</td> <td></td> </tr> <tr> <td>for (i = 1; i &lt; m; i++) {</td> <td></td> </tr> <tr> <td>if (obstacleGrid[i][0] == 1) {</td> <td></td> </tr> <tr> <td>f[i][0] = 0;</td> <td></td> </tr> <tr> <td>} else {</td> <td></td> </tr> <tr> <td>f[i][0] = f[i-1][0];</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>for (j = 1; j &lt; n; j++) {</td> <td></td> </tr> <tr> <td>if (obstacleGrid[0][j] == 1) {</td> <td></td> </tr> <tr> <td>f[0][j] = 0;</td> <td></td> </tr> <tr> <td>} else {</td> <td></td> </tr> <tr> <td>f[0][j] = f[0][j-1];</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>for (i = 1; i &lt; m; i++) {</td> <td></td> </tr> <tr> <td>for (j = 1; j &lt; n; j++) {</td> <td></td> </tr> <tr> <td>if (obstacleGrid[i][j] == 1) {</td> <td></td> </tr> <tr> <td>f[i][j] = 0;</td> <td></td> </tr> <tr> <td>} else {</td> <td></td> </tr> <tr> <td>f[i][j] = f[i][j-1] + f[i-1][j];</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td></td> <td></td> </tr> <tr> <td>return f[m-1][n-1];</td> <td></td> </tr> <tr> <td>}</td> <td></td> </tr> <tr> <td>};</td> <td></td> </tr> <tr> <td>```</td> <td></td> </tr> </tbody> </table> <p>```C++ tab="C++ Naive DP Refactored" class Solution { public: int uniquePathsWithObstacles(vector<vector\&lt;int>>&amp; obstacleGrid) { int m = obstacleGrid.size(); int n = m &gt; 0 ? obstacleGrid[0].size() : 0; if (m == 0 &amp;&amp; n == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n, 0));

    f[0][0] = 1;

    if (obstacleGrid[0][0] == 1) {
        return 0;
    }

    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (obstacleGrid[i][j] == 1) {
                f[i][j] = 0;
            } else {
                // whenever available
                if (i &gt; 0) {
                    f[i][j] += f[i - 1][j];
                }

                if (j &gt; 0) {
                    f[i][j] += f[i][j - 1];
                }
            }
        }
    }

    return f[m - 1][n - 1];
}
</code></pre></div> <p>}; <code></code>Java tab="Java O(n) space" // Optimized using a rolling array or single row dp array instead of m x n. class Solution { public int uniquePathsWithObstacles(int[][] a) { int m = a.length; int n = a[0].length; int dp[] = new int[n]; dp[0] = 1; //T[i][j] = T[i-1][j] + T[i][j-1] for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(a[i][j] == 1){ dp[j] = 0; }else if(j &gt; 0){ dp[j] += dp[j-1]; } } } return dp[n-1]; } } ```</p> <h3 id=paint-house>Paint House<a class=headerlink href=#paint-house title="Permanent link">&para;</a></h3> <ul> <li>DP last step: considering the optimal solution. The last paint must be one of the three colors and the paint cost is minimum.</li> <li>State: we can try to name <code>f[i]</code> the minimum cost of painting the first <code>i</code> houses, <code>i = 0, 1, ... i-1</code>. However, we cannot know what color could be used for the last house.</li> <li>Change the state to: <code>f[i][k]</code> is the minium cost of painting the first <code>i</code> houses and the <code>i-1</code>th element is painted as color <code>k</code>. This way, we can choose the last paint based on this piece of information.</li> <li>The state transition fomular: <span><span class=MathJax_Preview>f[i][k] = f[i - 1][\ell]_{\ell != k} + costs[i - 1][k]</span><script type=math/tex>f[i][k] = f[i - 1][\ell]_{\ell != k} + costs[i - 1][k]</script></span></li> <li>The result is minimum of the: <span><span class=MathJax_Preview>f[i][0],\ f[i][1],\ f[i][2]</span><script type=math/tex>f[i][0],\ f[i][1],\ f[i][2]</script></span></li> </ul> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>minCost</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&amp;</span> <span class=n>costs</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>costs</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=kt>int</span> <span class=n>f</span><span class=p>[</span><span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=mi>3</span><span class=p>];</span>
        <span class=cm>/* state: f[i][0] paint i house and the last (i - 1) house is red *</span>
<span class=cm>        /* initial value, paint 0 house cost 0 */</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
            <span class=n>f</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// current color</span>
                <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>INT_MAX</span><span class=p>;</span>
                <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// painted color</span>
                    <span class=cm>/* cannot paint same color for neighbor house */</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=n>k</span><span class=p>)</span>
                        <span class=k>continue</span><span class=p>;</span>

                    <span class=c1>// ith (index with i - 1) house is painted with color j</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>costs</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
                        <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>costs</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>

                    <span class=c1>//f[i][j] = min(f[i - 1][k] + costs[i - 1][j], f[i][j]);</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>min</span><span class=p>(</span><span class=n>min</span><span class=p>(</span><span class=n>f</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>f</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=mi>1</span><span class=p>]),</span> <span class=n>f</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=mi>2</span><span class=p>]);</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <h3 id=decode-ways>Decode Ways<a class=headerlink href=#decode-ways title="Permanent link">&para;</a></h3> <p>4 Ingredients</p> <ol> <li> <p>Last step:</p> <div class=highlight><pre><span></span><code>A_0, A_1, A_2, ..., A_n-3, [A_n-2, A_n-1]
A_0, A_1, A_2, ..., A_n-3, A_n-2, [A_n-1]
</code></pre></div> </li> <li> <p>State: <code>f[n]</code>: decode ways of first <code>n</code> letters.</p> </li> <li>Smaller problem: <code>f[n] = f[n - 1] + f[n - 2] | A_n-2,A_n-1</code> decodable.</li> <li>Init: <code>f[0] = 1</code></li> </ol> <div class="admonition note"> <p class=admonition-title>Note</p> <p>Again the idea in this solution is to update the <code>f[i][j]</code> on demand, a technique that broadly used in 2-d coordinate based DP problems such as <a href=#bomb-enemy>Bomb Enemy</a>, <a href=#unique-paths-ii>Unique Paths II</a>, and <a href=#minimum-path-sum>Minimum Path Sum</a>.</p> </div> <p>```C++ tab="C++ DP" class Solution { public: int numDecodings(string s) { int n = s.length(); int f[n + 1] = {0}; if (n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    f[0] = 1;
    for (int i = 1; i &lt;= n; i++) {
        int t = s[i - 1] - &#39;0&#39;;
        if (t &gt; 0 &amp;&amp; t &lt;= 9) {
            f[i] += f[i - 1];
        }

        if (i &gt; 1){
            int q = (s[i - 2] - &#39;0&#39;) * 10 + t;
            if (q &gt;= 10 &amp;&amp; q &lt;= 26) {
                f[i] += f[i - 2];
            }
        }
    }

    return f[n];
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ DP O(1)" class Solution { public: int numDecodings(string s) { if (!s.size() || s.front() == '0') return 0; // r2: decode ways of s[0, i-2] , r1: decode ways of s[0, i-1] int r1 = 1, r2 = 1; // think it as a coordinate bases, not sequence based dp for (int i = 1; i &lt; s.size(); i++) { // last char in s[0, i] is 0, cannot decode if (s[i] == '0') r1 = 0; // two-digit letter, add r2 to r1, r2 get the previous r1 if (s[i - 1] == '1' || s[i - 1] == '2' &amp;&amp; s[i] &lt;= '6') { r1 = r2 + r1; r2 = r1 - r2; } else { // one-digit letter, r2 get the previous r1 r2 = r1; } } return r1; } }; ```</p> <h3 id=longest-increasing-continuous-subsequence>Longest Increasing Continuous Subsequence<a class=headerlink href=#longest-increasing-continuous-subsequence title="Permanent link">&para;</a></h3> <p>4 ingredients:</p> <ol> <li>Last step, last element <code>a[n-1]</code> could be in the result or not in the result.</li> <li>subproblem, suppose we have the LICS of the first <code>n - 1</code> elements. represented as <code>f[n-1]</code>.</li> <li>base case and boundary condition, when no char in the string: <code>f[0] = 1</code>. empty string have LICS length of 1.</li> <li>order of calculation, calculate small index first.</li> </ol> <div class="admonition note"> <p class=admonition-title>Not a leetcode</p> <p>The problem is not a leetcode problem, the original problem ask for sequence that could be increase or decrease.</p> </div> <div class="admonition warning"> <p class=admonition-title>Using index in DP problems</p> <p>Avoid using both index <code>i - 1</code> and <code>i + 1</code> in a loop invariance, otherwise you'll have problem in keeping the loop invariance. Compare the followings.</p> <p>```C++ tab="Incorrect" for (int i = n - 1; i &gt;= 0; i--) { f[i] = 1; if (i &lt; n - 1 &amp;&amp; i &gt; 0 &amp;&amp; A[i - 1] &gt; A[i]) { f[i] = f[i + 1] + 1; } res2 = max(res2, f[i]); } <div class=highlight><pre><span></span><code>```C++ tab=&quot;Correct&quot;
for (int i = n - 1; i &gt;= 0; i--) {
    f[i] = 1;
    if (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) {
        f[i] = f[i + 1] + 1;
    }
    res2 = max(res2, f[i]);
}
</code></pre></div></p> <p><code>C++ tab="Correct" for (int i = 0; i &lt; n; i++) { f[i] = 1; if (i &gt; 0 &amp;&amp; A[i - 1] &gt; A[i]) { f[i] = f[i - 1] + 1; } res2 = max(res2, f[i]); }</code> </p> </div> <p>```C++ tab="C++ DP solution" class Solution { public: int longestIncreasingContinuousSubsequence(vector<int>&amp; A) { // Write your code here int n = A.size(); int f[n]; int res1 = 0; int res2 = 0;</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; n; i++) {
        f[i] = 1;
        if (i &gt; 0 &amp;&amp; A[i - 1] &lt; A[i]) {
            f[i] = f[i - 1] + 1;
        }
        res1 = max(res1, f[i]);
    }

    for (int i = n - 1; i &gt;= 0; i--) {
        f[i] = 1;
        if (i &lt; n - 1 &amp;&amp; A[i] &gt; A[i + 1]) {
            f[i] = f[i + 1] + 1;
        }
        res2 = max(res2, f[i]);
    }

    return max(res1, res2);
}
</code></pre></div> <p>}; <code>`` Here we don't have to explicitly wirte</code>f[i] = max(1, f[i - 1] + 1)<code>, since we have the condition</code>A[i - 1] &lt; A[i]<code>, we know the</code>A[i]<code>will be added to the</code>f[i]<code>, hence simply update</code>f[i] = f[i - 1] + 1` directly. </p> <h3 id=minimum-path-sum>Minimum Path Sum<a class=headerlink href=#minimum-path-sum title="Permanent link">&para;</a></h3> <ul> <li>This is coordinate based DP. We need to have <code>f[i][j]</code> to keep the minimum path sum to the <code>grid[i][j]</code>.</li> <li>Calculate <code>f[i][j]</code> from top to down and from left to right for each row. Space can be optimized.</li> <li>Notice we can do the init and first row and first column in nested loops, do not need use multiple for loops. <code>C++ tab="C++ DP" class Solution { public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) { int m = grid.size(); int n = grid[0].size(); if (m == 0 || n == 0) return 0; int f[m][n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0 &amp;&amp; j == 0) { f[i][j] = grid[i][j]; } if (i == 0 &amp;&amp; j &gt; 0) { f[i][j] = f[i][j - 1] + grid[i][j]; } if (j == 0 &amp;&amp; i &gt; 0) { f[i][j] = f[i - 1][j] + grid[i][j]; } if (i &gt; 0 &amp;&amp; j &gt; 0) { f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; } } } return f[m - 1][n - 1]; } };</code></li> </ul> <p>```C++ tab="C++ DP Space O(n)" class Solution { public: int minPathSum(vector<vector\&lt;int> > &amp;grid) { int m = grid.size(); int n = grid[0].size(); if (m == 0 || n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    int f[2][n]; /* only two rows of status */
    int prev = 1;
    int curr = 1;
    for (int i = 0; i &lt; m; i++) {
        // rolling the f array when move to a new row
        prev = curr;
        curr = 1 - curr;  
        for (int j = 0; j &lt; n; j++) {
            f[curr][j] = grid[i][j];

            if (i == 0 &amp;&amp; j &gt; 0) {
                f[i][j] += f[i][j - 1];
            }

            if (j == 0 &amp;&amp; i &gt; 0) {
                f[curr][j] += f[prev][j];
            }

            if (i &gt; 0 &amp;&amp; j &gt; 0) {
                f[curr][j] += min(f[prev][j], f[curr][j - 1]);
            }

        }
    }

    return f[curr][n - 1];
}
</code></pre></div> <div class="admonition note"> <p class=admonition-title>Note</p> <ol> <li>在处理二维坐标型DP问题的时候，对于第一行或者第一列的计算我们可以把它放到loop中。但是要加一个条件。 这个条件就是 <code>if (i &gt; 0)</code>, 这个条件保证了在更新数组值的时候下标不会越界。并且很好的诠释了我们的动机（就是对于第一行第一列仅仅是初始化)。</li> <li>对于1中提到的trick，另外一个好处就是对于第一行或者第一列条件判断的时候，这里还有一个技巧就是先把自身的‘性质’或者‘值’加上， 如果有上一行我们再去加上一行的‘性质’或‘值’。这里需要逆向思维.</li> <li>在多种情况需要分开讨论的时候我们可以先‘一票否决’最明显情况，然后讨论剩下的情况。 </li> </ol> </div> <h3 id=bomb-enemy>Bomb Enemy<a class=headerlink href=#bomb-enemy title="Permanent link">&para;</a></h3> <ul> <li>Breakdown the problem into smaller (simpler) problems.</li> <li>Take the special steps (i.e. different properties of the cell) as normal ones in the loop, deal with the special step when doing the calculation. <code>C++ class Solution { public: int maxKilledEnemies(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { int m = grid.size(); if (m == 0) return 0; int n = grid[0].size(); if (n == 0) return 0; int f[m][n]; int res[m][n]; int ret = 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { res[i][j] = 0; } } /* up */ for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { f[i][j] = 0; if (grid[i][j] == 'W') { f[i][j] = 0; } else { if (grid[i][j] == 'E') { f[i][j] = 1; } if (i &gt; 0) { f[i][j] += f[i - 1][j]; } } res[i][j] += f[i][j]; } } /* down */ for (int i = m - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; n; j++) { f[i][j] = 0; if (grid[i][j] == 'W') { f[i][j] = 0; } else { if (grid[i][j] == 'E') { f[i][j] = 1; } if (i &lt; m - 1) { f[i][j] += f[i + 1][j]; } } res[i][j] += f[i][j]; } } /* left */ for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { f[i][j] = 0; if (grid[i][j] == 'W') { f[i][j] = 0; } else { if (grid[i][j] == 'E') { f[i][j] = 1; } if (j &gt; 0) { f[i][j] += f[i][j - 1]; } } res[i][j] += f[i][j]; } } /* right */ for (int i = 0; i &lt; m; i++) { for (int j = n - 1; j &gt;= 0; j--) { f[i][j] = 0; if (grid[i][j] == 'W') { f[i][j] = 0; } else { if (grid[i][j] == 'E') { f[i][j] = 1; } if (j &lt; n - 1) { f[i][j] += f[i][j + 1]; } } res[i][j] += f[i][j]; } } /* calculate resutls */ for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (grid[i][j] == '0') if (res[i][j] &gt; ret) ret = res[i][j]; } } return ret; } };</code></li> </ul> <h3 id=counting-bits>Counting Bits<a class=headerlink href=#counting-bits title="Permanent link">&para;</a></h3> <ul> <li>Notice you can use the trick that <code>i &gt;&gt; 1 == i / 2</code> to construct the subproblem</li> </ul> <table> <thead> <tr> <th>i</th> <th>count 1 bits</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>1</td> </tr> <tr> <td>2</td> <td>1</td> </tr> <tr> <td>3</td> <td>2</td> </tr> <tr> <td>6</td> <td>2</td> </tr> <tr> <td>12</td> <td>2</td> </tr> <tr> <td>25</td> <td>3</td> </tr> <tr> <td>50</td> <td>3</td> </tr> </tbody> </table> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>countBits</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>f</span><span class=p>(</span><span class=n>num</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>num</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=p>(</span><span class=n>i</span> <span class=o>%</span> <span class=mi>2</span><span class=p>);</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>f</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <h2 id=lecture-3-dynamic-programming-on-sequences>Lecture 3 Dynamic Programming on Sequences<a class=headerlink href=#lecture-3-dynamic-programming-on-sequences title="Permanent link">&para;</a></h2> <table> <thead> <tr> <th>Problem</th> <th>Category</th> </tr> </thead> <tbody> <tr> <td><a href=#paint-house-ii>Paint House II</a></td> <td>序列型＋状态</td> </tr> <tr> <td><a href=#house-robber>House Robber</a></td> <td>序列型＋状态</td> </tr> <tr> <td><a href=#house-robber-ii>House Robber II</a></td> <td>序列型＋状态</td> </tr> <tr> <td><a href=#best-time-to-buy-and-sell-stock>Best Time to Buy and Sell Stock</a></td> <td></td> </tr> <tr> <td><a href=#best-time-to-buy-and-sell-stock-ii>Best Time to Buy and Sell Stock II</a></td> <td></td> </tr> <tr> <td><a href=#best-time-to-buy-and-sell-stock-iii>Best Time to Buy and Sell Stock III</a></td> <td>序列型＋状态</td> </tr> <tr> <td><a href=#best-time-to-buy-and-sell-stock-iv>Best Time to Buy and Sell Stock IV</a></td> <td>序列型＋状态</td> </tr> <tr> <td><a href=#longest-increasing-subsequence>Longest Increasing Subsequence</a></td> <td>序列型</td> </tr> <tr> <td><a href=#russian-doll-envelopes>Russian Doll Envelopes</a></td> <td></td> </tr> </tbody> </table> <h3 id=_1>序列型动态规划<a class=headerlink href=#_1 title="Permanent link">&para;</a></h3> <p>给定一个序列</p> <ol> <li>动态规划方程<code>f[i]</code>中的下标<code>i</code>表示前<code>i</code>个元素<code>a[0], a[1], ..., a[i-1]</code>的某种性质<ul> <li>坐标型的<code>f[i]</code>表示以<code>a[i]</code>为结尾的某种性质</li> </ul> </li> <li>初始化中，<code>f[0]</code>表示空序列的性质<ul> <li>坐标型动态规划的初始条件<code>f[0]</code>就是指以<code>a[0]</code>为结尾的子序列的性质</li> </ul> </li> </ol> <h3 id=paint-house-ii>Paint House II<a class=headerlink href=#paint-house-ii title="Permanent link">&para;</a></h3> <ul> <li>the solution could be the same as the first verison, but it is <span><span class=MathJax_Preview>O(n\cdot k^2)</span><script type=math/tex>O(n\cdot k^2)</script></span>. how to make it <span><span class=MathJax_Preview>O(n\cdot k)</span><script type=math/tex>O(n\cdot k)</script></span>?</li> <li> <p>By analyzing the state transition equation, we observed that we want to find a minimum value of a set of numbers except one for each house. Put it in english, the min cost to paint <code>i - 1</code>th house with color <code>k</code>, we want to have the min cost of painting all previous <code>i - 1</code> houses and the <code>i-1</code>th house cannot be painted as color <code>k</code>.</p> <div class=highlight><pre><span></span><code><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>{</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=p>...,</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>1</span><span class=p>]}</span>
<span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>{</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>3</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>2</span><span class=p>],</span> <span class=p>...,</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>2</span><span class=p>]}</span>
<span class=p>...</span>
<span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>K</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>{</span><span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=p>],</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=p>],</span> <span class=p>...,</span> <span class=n>f</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=mi>-1</span><span class=p>]</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span><span class=mi>-1</span><span class=p>][</span><span class=n>K</span><span class=p>]}</span>
</code></pre></div> </li> <li> <p>We could optimize the solution upon this. Basically, we can maintain the first two minimum value of the set <code>f[i-1][1], f[i-1][2], f[i-1][3], ..., f[i-1][K]</code>, <code>min1</code> and <code>min2</code> and their index <code>j1</code> and <code>j2</code>.</p> <ol> <li>There are two cases, the first case is the house <code>i-1</code> is painted with the same color correspoinding to the minimum value. in this case, we cannot chose to paint it with the color corresponding to the minimum cost, we can update the state using the second minimum.</li> <li>The second case is that we paint the i-1th house with color other than the color corresponding to the minimum cost to pain, we can update using the minimum value.</li> </ol> </li> </ul> <p>```C++ tab="C++ O(nk)" class Solution { public: /*<em> * @param costs n x k cost matrix * @return an integer, the minimum cost to paint all houses </em>/ int minCostII(vector<vector\&lt;int>>&amp; costs) { int m = costs.size(); if (m == 0) return 0; int k = costs[0].size(); if (k == 0) return 0;</p> <div class=highlight><pre><span></span><code>    int f[m + 1][k];

    int min1;
    int min2;
    int j1 = 0, j2 = 0;

    /* init, 0 house cost nothing. */
    for (int j = 0; j &lt; k; j++)
        f[0][j] = 0;

    for (int i = 1; i &lt;= m; i++) {
        min1 = min2 = INT_MAX; 
        /* from all the colors, find the min1 and min2 */
        for (int j = 0; j &lt; k; j++) {
            /* get the min1 and min2 first */
            if (f[i - 1][j] &lt; min1) {
                min2 = min1;
                j2 = j1;
                min1 = f[i - 1][j];
                j1 = j;
            } else if (f[i - 1][j] &lt; min2) {
                min2 = f[i - 1][j];
                j2 = j;
            }
        }

        /* update the states based on the min1 and min2 */
        for (int j = 0; j &lt; k; j++) {
            if (j != j1) {
                f[i][j] = f[i - 1][j1] + costs[i - 1][j];
            } else {
                f[i][j] = f[i - 1][j2] + costs[i - 1][j];
            }
        }
    }

    int res = INT_MAX;
    for (int j = 0; j &lt; k; j++) {
        if (f[m][j] &lt; res)
            res = f[m][j];
    }

    return res;
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ O(nk^2)" class Solution { public: int minCostII(vector<vector\&lt;int>>&amp; costs) { int n = costs.size(); int k = n &gt; 0 ? costs[0].size() : 0; if (n == 0 &amp;&amp; k == 0) return 0; if (n == 1 &amp;&amp; k == 1) return costs[0][0]; vector<vector\&lt;int>> f(n + 1, vector<int>(k, 0)); for (int i = 0; i &lt; k; i++) { f[0][i] = 0; // 0 cost for 0 paint } for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; k; j++) { f[i][j] = INT_MAX; for (int c = 0; c &lt; k; c++) { if (j == c) { continue; } if (f[i][j] &gt; f[i - 1][c] + costs[i - 1][j]) { f[i][j] = f[i - 1][c] + costs[i - 1][j]; } } } } int res = INT_MAX; for (int i = 0; i &lt; k; i++) { if (f[n][i] &lt; res) res = f[n][i]; } return res; } }; ```</p> <h3 id=house-robber>House Robber<a class=headerlink href=#house-robber title="Permanent link">&para;</a></h3> <ul> <li>Start with the last step. The last house could be either robbed or not.<ol> <li>If the last house <code>a[i-1]</code> is robbed, then we cannot rob <code>a[i-2]</code>. we have <code>f[i] = f[i-2] + a[i-1]</code>.</li> <li>If the last house <code>a[i-1]</code> is not robbed, then we can rob <code>a[i-2]</code>. Alternatively, we can skip it to rob <code>a[i-3]</code>. We have <code>f[i] = f[n-1]</code>, in which this <code>f[n-1]</code> could not let us know whether <code>a[i-2]</code> is robbed or not.</li> </ol> </li> <li>We add the state of <code>a[i-1]</code> to the state transition equation. Thus we have:<ol> <li><code>f[i][0]</code> represent "the maximum money for robbing the first <code>i</code> houses and the last house <strong>hasn't</strong> been robbed."</li> <li><code>f[i][1]</code> represent "the maximum money for robbing the first <code>i</code> houses and the last house <strong>has</strong> been robbed."</li> </ol> </li> <li> <p>state transition equations:</p> <div class=highlight><pre><span></span><code>f[i][0] = max(f[i-1][0], f[i-1][1])
f[i][1] = f[i-1][0] + a[i-1]
</code></pre></div> </li> </ul> <p>```C++ tab="C++" class Solution { public: int rob(vector<int>&amp; nums) { int n = nums.size(); if (n == 0) return 0; int f[n + 1][2] = {0};</p> <div class=highlight><pre><span></span><code>    for (int i = 1; i &lt;= n; i++) {
        f[i][0] = max(f[i - 1][0], f[i - 1][1]);
        f[i][1] = f[i - 1][0] + nums[i - 1];
    }

    return max(f[n][0], f[n][1]);
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ optimized" class Solution { public: long long houseRobber(vector<int> A) { int n = A.size(); if (n == 0) return 0; long long f[n+1]; /<em> init </em>/ f[0] = 0; f[1] = A[0]; for (int i = 2; i &lt;= n; i++) { f[i] = max(f[i - 1], f[i - 2] + A[i - 1]); } return f[n]; } }; ```</p> <p>Solution 2</p> <ul> <li><code>yes</code> - first <code>i</code> days, robber last day,</li> <li><code>no</code> - first <code>i</code> days, not robber at last day.</li> </ul> <p>```C++ tab= class Solution { public: int rob(vector<int>&amp; nums) { int n = nums.size(); if (n == 0) return 0; int yes = 0, no = 0;</p> <div class=highlight><pre><span></span><code>    for (int i = 1; i &lt;= n; i++) {
        int tmp = no;
        no = max(yes, no);
        yes = tmp + nums[i - 1];
    }

    return max(yes, no);
}
</code></pre></div> <p>}; ``` </p> <h3 id=house-robber-ii>House Robber II<a class=headerlink href=#house-robber-ii title="Permanent link">&para;</a></h3> <ul> <li>Following <a href=#house-robber>House Robber</a>, when we try to analyze the last step, the house <code>i - 1</code> depends on the house <code>i - 2</code> and the house <code>0</code>. How could we handle this?</li> <li>We could enumerate two cases, and reduce the probelm to <a href=#house-robber>House Rober</a><ol> <li>house <code>0</code> is robbed and house <code>i-1</code> is not.</li> <li>house <code>i - 1</code> is robbed and house <code>0</code> is not. <code>C++ class Solution { public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 0) return 0; if (n == 1) // edge case to deal with return nums[0]; vector&lt;int&gt; nums1(nums.begin() + 1, nums.end()); vector&lt;int&gt; nums2(nums.begin(), nums.end() - 1); return max(rob_helper(nums1), rob_helper(nums2)); } private: int rob_helper(vector&lt;int&gt;&amp; A) { int n = A.size(); if (n == 0) return 0; int f[n+1] = {0}; f[0] = 0; f[1] = A[0]; for (int i = 2; i &lt;= n; i++) { f[i] = max(f[i - 1], f[i - 2] + A[i - 1]); } return f[n]; } };</code></li> </ol> </li> </ul> <h3 id=best-time-to-buy-and-sell-stock>Best Time to Buy and Sell Stock<a class=headerlink href=#best-time-to-buy-and-sell-stock title="Permanent link">&para;</a></h3> <ul> <li>Force youself to do it by only one pass. You'll find that you need two variables to record the minimum value currently found and the maximum profit currently found.</li> </ul> <div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
    <span class=kt>int</span> <span class=n>maxProfit</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>prices</span><span class=p>)</span> <span class=p>{</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>prices</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>

        <span class=kt>int</span> <span class=n>min_price</span> <span class=o>=</span> <span class=n>INT_MAX</span><span class=p>;</span>
        <span class=kt>int</span> <span class=n>max_profit</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>

        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>min_price</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>min_price</span> <span class=o>=</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
            <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>min_price</span> <span class=o>&gt;</span> <span class=n>max_profit</span><span class=p>)</span> <span class=p>{</span>
                <span class=n>max_profit</span> <span class=o>=</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>min_price</span><span class=p>;</span>
            <span class=p>}</span>
        <span class=p>}</span>

        <span class=k>return</span> <span class=n>max_profit</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>};</span>
</code></pre></div> <h3 id=best-time-to-buy-and-sell-stock-ii>Best Time to Buy and Sell Stock II<a class=headerlink href=#best-time-to-buy-and-sell-stock-ii title="Permanent link">&para;</a></h3> <ul> <li>We can just buy and sell when ever the price is increased in a day.</li> <li>Once you can proof the day-by-day subproblem can form the solution. The solution becomes so easy.</li> </ul> <p>```C++ tab="C++" class Solution { public: int maxProfit(vector<int> &amp;prices) { int res = 0; for (int i = 1; i &lt; prices.size(); i++) { if (prices[i - 1] &lt; prices[i]) res += prices[i] - prices[i - 1]; }</p> <div class=highlight><pre><span></span><code>    return res;
}
</code></pre></div> <p>}; <code></code>C++ tab="C++ Alternative" class Solution { public: int maxProfit(vector<int> &amp;prices) { int res = 0; for (int i = 1; i &lt; prices.size(); i++) { res += max(prices[i] - prices[i - 1], 0) } return res; } }; ```</p> <h3 id=best-time-to-buy-and-sell-stock-iii>Best Time to Buy and Sell Stock III<a class=headerlink href=#best-time-to-buy-and-sell-stock-iii title="Permanent link">&para;</a></h3> <ul> <li>We can define 5 stages and write state transition equations based on it.</li> </ul> <p><img alt=buy-sell-stock-iii-sol src=../fig/buy-sell-stock-iii-sol.png></p> <p>```C++ tab="" class Solution { public: /*<em> * @param prices: Given an integer array * @return: Maximum profit </em>/ int maxProfit(vector<int> &amp;A) { int n = A.size(); if (n == 0) { return 0; }</p> <div class=highlight><pre><span></span><code>    int f[n+1][6];

    /* init */
    f[0][1] = 0;
    f[0][2] = f[0][3] = f[0][4] = f[0][5] = INT_MIN;

    for (int i = 1; i &lt;= n; i++) {
        // stage 1, 3, 5:
        // f[i][j] = max{f[i - 1][j], f[i - 1][j - 1] + A[i - 1] - A[i - 2]}
        for (int j = 1; j &lt;= 5; j += 2) {
            f[i][j] = f[i - 1][j];
            if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; f[i - 1][j - 1] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + A[i - 1] - A[i - 2]);
            }

        }

        // stage 2, 4:
        // f[i][j] = max{f[i - 1][j] + A[i - 1] - A[i - 2], f[i - 1][j - 1], f[i - 1][j - 2] + A[i - 1] - A[i - 2]}
        for (int j = 2; j &lt; 5; j += 2) {
            f[i][j] = f[i - 1][j - 1];
            if (i &gt; 1 &amp;&amp; f[i - 1][j] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j] + A[i - 1] - A[i - 2]);
            }

            if (i &gt; 1 &amp;&amp; j &gt; 2 &amp;&amp; f[i - 1][j - 2] != INT_MIN) {
                f[i][j] = max(f[i][j], f[i - 1][j - 2] + A[i - 1] - A[i - 2]);
            }
        }
    }

    return max(f[n][1], max(f[n][3], f[n][5]));
}
</code></pre></div> <p>}; ``` </p> <h3 id=best-time-to-buy-and-sell-stock-iv>Best Time to Buy and Sell Stock IV<a class=headerlink href=#best-time-to-buy-and-sell-stock-iv title="Permanent link">&para;</a></h3> <ul> <li>If <code>k</code> is larger then <code>n/2</code>, it is equivalent to the II.</li> <li>This is a generalized solution from <a href=#best-time-to-buy-and-sell-stock-iii>Best Time to Buy and Sell Stock III</a>. <code>C++ class Solution { public: int maxProfit(int K, vector&lt;int&gt; &amp;A) { int n = A.size(); if (n == 0) { return 0; } int f[n+1][2 * K + 1 + 1]; /* special case need to take care of */ if (K &gt; (n / 2)) { int res = 0; for (int i = 0; i + 1 &lt; n; i++) { if (A[i + 1] - A[i] &gt; 0) { res += A[i + 1] - A[i]; } } return res; } /* init */ f[0][1] = 0; for (int k = 2; k &lt;= 2 * K + 1; k++) { f[0][k] = INT_MIN; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= 2 * K + 1; j += 2) { f[i][j] = f[i - 1][j]; if (i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; f[i - 1][j - 1] != INT_MIN) { f[i][j] = max(f[i][j], f[i - 1][j - 1] + A[i - 1] - A[i - 2]); } } for (int j = 2; j &lt; 2 * K + 1; j += 2) { f[i][j] = f[i - 1][j - 1]; if (i &gt; 1 &amp;&amp; f[i - 1][j] != INT_MIN) { f[i][j] = max(f[i][j], f[i - 1][j] + A[i - 1] - A[i - 2]); } if (i &gt; 1 &amp;&amp; j &gt; 2 &amp;&amp; f[i - 1][j - 2] != INT_MIN) { f[i][j] = max(f[i][j], f[i - 1][j - 2] + A[i - 1] - A[i - 2]); } } } int res = INT_MIN; for (int j = 1; j &lt;= 2 * K + 1; j += 2 ) { if (f[n][j] &gt; res) res = f[n][j]; } return res; } };</code></li> </ul> <h3 id=longest-increasing-subsequence>Longest Increasing Subsequence<a class=headerlink href=#longest-increasing-subsequence title="Permanent link">&para;</a></h3> <ul> <li>Comparing to the problem <a href=#longest-increasing-continuous-subsequence>Longest Increasing Continuous Subsequence</a>. If the subsequence is not continous. we have to enumerate each of the previous element befor <code>A[j]</code>.</li> </ul> <p>Solution 1 DP O(n^2)</p> <p>```C++ tab="DP" class Solution { public: int lengthOfLIS(vector<int>&amp; nums) { int n = nums.size(); if (n == 0) return 0;</p> <div class=highlight><pre><span></span><code>    int res = 0;
    int f[n] = {0};

    for (int j = 0; j &lt; n; j++) {
        /* case 1: a[j] is the subsequence */
        f[j] = 1;

        /* case 2: LIS from a[0],...a[i] plus a[j] */
        for (int i = 0; i &lt; j; i++) {
            if (nums[i] &lt; nums[j] &amp;&amp; f[i] + 1 &gt; f[j])
                f[j] = f[i] + 1;
        }
        res = max(res, f[j]);
    }

    return res;
}
</code></pre></div> <p>}; <code>Solution 2 DP with binary search O(nlogn) * To reduce the complexity, we can try to find if there is any redundant work we have been done. or some how we could use some order information to avoid some of the calculation. * Focus on the real meaning of longest Increasing Subsequence. In fact, you are looking for the smallest value before `A[i]` that leads to the longest Increasing Subsequence so far. * use the state `f[i]` to record the LIS of the array `A[0], ... A[i -1]`. If we are at `f[j], j &gt; i`, we are looking for the largest `f[i]` value that have the smallest `A[i]`.</code>C++ tab="DP with binary search" class Solution { public: int longestIncreasingSubsequence(vector<int> nums) { int n = nums.size(); if (n == 0) return 0; //int f[n]; // b[i]: when f value is i, smallest a value (ending value) int b[n + 1]; int top = 0; b[0] = INT_MIN; // O(n) for (int i = 0; i &lt; n; i++) { // b[0] ~ b[top] // last value b[j] which is smaller than A[i] int start = 0, end = top; int mid; int j; // O(lgn) while (start &lt;= end) { mid = start + (end - start) / 2; if (b[mid] &lt; nums[i]) { j = mid; start = mid + 1; } else { end = mid - 1; } } // b[i]: length is j (f value is j), smallest ending value. // A[i] is after it. // f[i] = j + 1 // b[j + 1]: length is (j + 1), smallest ending value. // A[i] // B[j + 1] &gt;= A[i] b[j + 1] = nums[i]; if (j + 1 &gt; top) { top = j + 1; } } // b[top] stores the smallest ending value for an LIS return top; } }; ```</p> <p>Solution 3 DP with binary search refactored</p> <ul> <li>In observing the fact that we can use extra space to keep the "minimum elements see so far from nums that is the last element of LIS for the different length of such LISes".</li> <li>Different from the regular DP solution, our extra space b is storing element from nums, and the element stored in b are not necessary in order.</li> <li>The index i of elements in b related to the length of a LIS whose last element is <code>a[i]</code>. specifically, <code>i + 1 = length(LIS)</code>.</li> </ul> <p>```C++ tab="DP with binary search refactored" class Solution { public: int lengthOfLIS(vector<int>&amp; nums) { vector<int> b;</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; nums.size(); ++i) {
        int begin = 0, end = b.size();
        while (begin != end) {
            int mid = begin + (end - begin) / 2;
            if (b[mid] &lt; nums[i]) {
                begin = mid + 1;
            } else {
                end = mid;
            }
        }

        if (begin == b.size()) // nums[i] greater than all element in b
            b.push_back(nums[i]);
        else // begin point to next element no less than the target nums[i].
            b[begin] = nums[i];
    }

    return b.size();
}
</code></pre></div> <p>}; <code>Solution 4 C++ using lower_bound * we can use the lower_bound to replace the binary search routine in the above solution.</code>C++ tab="C++ using lower_bound" class Solution { public: int lengthOfLIS(vector<int>&amp; nums) { vector<int> b; for (auto a : nums) { auto it = lower_bound(b.begin(), b.end(), a); if (it == b.end()) b.push_back(a); else *it = a; } return b.size(); } }; ```</p> <h3 id=russian-doll-envelopes>Russian Doll Envelopes<a class=headerlink href=#russian-doll-envelopes title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code>
</code></pre></div> <h2 id=lecture-4>Lecture 4<a class=headerlink href=#lecture-4 title="Permanent link">&para;</a></h2> <h3 id=copy-books>Copy Books<a class=headerlink href=#copy-books title="Permanent link">&para;</a></h3> <h2 id=lecture-7>Lecture 7<a class=headerlink href=#lecture-7 title="Permanent link">&para;</a></h2> <h3 id=403-frog-jump>403. Frog Jump<a class=headerlink href=#403-frog-jump title="Permanent link">&para;</a></h3> <ul> <li>You could use naive solution to iterate all the possible cases and use memoization to speed up.</li> <li>In that case, you can also use binary search to located a stone in the array which help to improve the complexity.</li> <li>But the best solution is to use a map to keep all the possible steps for a stone.</li> </ul> <p>```C++ tab="C++ map to set" class Solution { public: bool canCross(vector<int>&amp; stones) { int n = stones.size(); unordered_map<int, unordered_set\&lt;int>> hmap;</p> <div class=highlight><pre><span></span><code>    for (int i = 0; i &lt; stones.size(); i++) {
        hmap[stones[i]] = unordered_set&lt;int&gt;();
    }

    hmap[stones[0]].insert(0);

    for (int i = 0; i &lt; stones.size(); i++) {
        for (int k: hmap[stones[i]]) {
            for (int s = k - 1; s &lt;= k + 1; s++) {
                if (s &gt; 0 &amp;&amp; hmap.find(stones[i] + s) != hmap.end()) {
                    hmap[stones[i] + s].insert(s);
                }
            }
        }
    }

    return hmap[stones[n - 1]].size() &gt; 0;
}
</code></pre></div> <p>}; ```</p> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../../9chap-system-design/notes/ class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Nine Chapter System Design </div> </div> </a> <a href=../../func-prog-in-scala/notes/ class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Functional Programming Principles in Scala </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Rui Han </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <script src=../../../assets/javascripts/vendor.77e55a48.min.js></script> <script src=../../../assets/javascripts/bundle.9554a270.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script> <script>
        app = initialize({
          base: "../../..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.4ac00218.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>